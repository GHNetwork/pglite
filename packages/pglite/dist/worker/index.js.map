{"version":3,"sources":["../../src/worker/index.ts"],"sourcesContent":["import type {\n  DebugLevel,\n  ExecProtocolResult,\n  Extensions,\n  PGliteInterface,\n  PGliteInterfaceExtensions,\n  PGliteOptions,\n  Transaction,\n} from '../interface.js'\nimport type { PGlite } from '../pglite.js'\nimport { BasePGlite } from '../base.js'\nimport { toPostgresName, uuid } from '../utils.js'\nimport { DumpTarCompressionOptions } from '../fs/tarUtils.js'\nimport { BackendMessage } from '@electric-sql/pg-protocol/messages'\n\nexport type PGliteWorkerOptions<E extends Extensions = Extensions> =\n  PGliteOptions<E> & {\n    meta?: any\n    id?: string\n  }\n\nexport class PGliteWorker\n  extends BasePGlite\n  implements PGliteInterface, AsyncDisposable\n{\n  #initPromise: Promise<void>\n  #debug: DebugLevel = 0\n\n  #ready = false\n  #closed = false\n  #isLeader = false\n\n  #eventTarget = new EventTarget()\n\n  #tabId: string\n\n  #connected = false\n\n  #workerProcess: Worker\n  #workerID?: string\n  #workerHerePromise?: Promise<void>\n  #workerReadyPromise?: Promise<void>\n\n  #broadcastChannel?: BroadcastChannel\n  #tabChannel?: BroadcastChannel\n  #releaseTabCloseLock?: () => void\n\n  #notifyListeners = new Map<string, Set<(payload: string) => void>>()\n  #globalNotifyListeners = new Set<(channel: string, payload: string) => void>()\n\n  #extensions: Extensions\n  #extensionsClose: Array<() => Promise<void>> = []\n\n  constructor(worker: Worker, options?: PGliteWorkerOptions) {\n    super()\n    this.#workerProcess = worker\n    this.#tabId = uuid()\n    this.#extensions = options?.extensions ?? {}\n\n    this.#workerHerePromise = new Promise<void>((resolve) => {\n      this.#workerProcess.addEventListener(\n        'message',\n        (event) => {\n          if (event.data.type === 'here') {\n            resolve()\n          } else {\n            throw new Error('Invalid message')\n          }\n        },\n        { once: true },\n      )\n    })\n\n    this.#workerReadyPromise = new Promise<void>((resolve) => {\n      const callback = (event: MessageEvent<any>) => {\n        if (event.data.type === 'ready') {\n          this.#workerID = event.data.id\n          this.#workerProcess.removeEventListener('message', callback)\n          resolve()\n        }\n      }\n      this.#workerProcess.addEventListener('message', callback)\n    })\n\n    this.#initPromise = this.#init(options)\n  }\n\n  /**\n   * Create a new PGlite instance with extensions on the Typescript interface\n   * This also awaits the instance to be ready before resolving\n   * (The main constructor does enable extensions, however due to the limitations\n   * of Typescript, the extensions are not available on the instance interface)\n   * @param worker The worker to use\n   * @param options Optional options\n   * @returns A promise that resolves to the PGlite instance when it's ready.\n   */\n  static async create<O extends PGliteWorkerOptions>(\n    worker: Worker,\n    options?: O,\n  ): Promise<PGliteWorker & PGliteInterfaceExtensions<O['extensions']>> {\n    const pg = new PGliteWorker(worker, options)\n    await pg.#initPromise\n    return pg as PGliteWorker & PGliteInterfaceExtensions<O['extensions']>\n  }\n\n  async #init(options: PGliteWorkerOptions = {}) {\n    // =============================================================================\n    // DIAGNOSTIC LOGGING (Phase 1 - main thread side of worker)\n    // =============================================================================\n    const _now = () => (typeof performance !== 'undefined' && performance.now ? performance.now() : Date.now())\n    const t0 = _now()\n    const stamp = () => `+${(_now() - t0).toFixed(1)}ms`\n\n    console.info(`[PGliteInternal][worker-main] ${stamp()} ========== PGliteWorker #init START ==========`)\n    console.debug(`[PGliteInternal][worker-main] ${stamp()} tabId=${this.#tabId}, dataDir=${options.dataDir ?? 'memory://'}`)\n\n    // Setup the extensions\n    const extensionCount = Object.keys(this.#extensions).length\n    console.debug(`[PGliteInternal][worker-main] ${stamp()} setting up ${extensionCount} extension(s) on client side...`)\n    const extSetupStart = _now()\n    for (const [extName, ext] of Object.entries(this.#extensions)) {\n      if (ext instanceof URL) {\n        throw new Error(\n          'URL extensions are not supported on the client side of a worker',\n        )\n      } else {\n        const extRet = await ext.setup(this, {}, true)\n        if (extRet.emscriptenOpts) {\n          console.warn(\n            `PGlite extension ${extName} returned emscriptenOpts, these are not supported on the client side of a worker`,\n          )\n        }\n        if (extRet.namespaceObj) {\n          const instance = this as any\n          instance[extName] = extRet.namespaceObj\n        }\n        if (extRet.bundlePath) {\n          console.warn(\n            `PGlite extension ${extName} returned bundlePath, this is not supported on the client side of a worker`,\n          )\n        }\n        if (extRet.init) {\n          await extRet.init()\n        }\n        if (extRet.close) {\n          this.#extensionsClose.push(extRet.close)\n        }\n      }\n    }\n    console.debug(`[PGliteInternal][worker-main] ${stamp()} extensions setup completed (took ${(_now() - extSetupStart).toFixed(1)}ms)`)\n\n    // Wait for the worker let us know it's here\n    console.debug(`[PGliteInternal][worker-main] ${stamp()} awaiting workerHerePromise (waiting for worker to post 'here')...`)\n    const hereWaitStart = _now()\n    await this.#workerHerePromise\n    console.info(`[PGliteInternal][worker-main] ${stamp()} workerHerePromise resolved (waited ${(_now() - hereWaitStart).toFixed(1)}ms)`)\n\n    // Send the worker the options\n    const { extensions: _, ...workerOptions } = options\n    console.debug(`[PGliteInternal][worker-main] ${stamp()} posting 'init' message to worker with options`)\n    this.#workerProcess.postMessage({\n      type: 'init',\n      options: workerOptions,\n    })\n\n    // Wait for the worker let us know it's ready\n    console.debug(`[PGliteInternal][worker-main] ${stamp()} awaiting workerReadyPromise (waiting for worker to post 'ready')...`)\n    const readyWaitStart = _now()\n    await this.#workerReadyPromise\n    console.info(`[PGliteInternal][worker-main] ${stamp()} workerReadyPromise resolved (waited ${(_now() - readyWaitStart).toFixed(1)}ms, workerID=${this.#workerID})`)\n\n    // Acquire the tab close lock, this is released then the tab, or this\n    // PGliteWorker instance, is closed\n    const tabCloseLockId = `pglite-tab-close:${this.#tabId}`\n    console.debug(`[PGliteInternal][worker-main] ${stamp()} acquiring tab close lock: ${tabCloseLockId}`)\n    const tabLockStart = _now()\n    this.#releaseTabCloseLock = await acquireLock(tabCloseLockId)\n    console.debug(`[PGliteInternal][worker-main] ${stamp()} tab close lock acquired (took ${(_now() - tabLockStart).toFixed(1)}ms)`)\n\n    // Start the broadcast channel used to communicate with tabs and leader election\n    const broadcastChannelId = `pglite-broadcast:${this.#workerID}`\n    this.#broadcastChannel = new BroadcastChannel(broadcastChannelId)\n    console.debug(`[PGliteInternal][worker-main] ${stamp()} broadcast channel created: ${broadcastChannelId}`)\n\n    // Start the tab channel used to communicate with the leader directly\n    const tabChannelId = `pglite-tab:${this.#tabId}`\n    this.#tabChannel = new BroadcastChannel(tabChannelId)\n    console.debug(`[PGliteInternal][worker-main] ${stamp()} tab channel created: ${tabChannelId}`)\n\n    this.#broadcastChannel.addEventListener('message', async (event) => {\n      if (event.data.type === 'leader-here') {\n        console.debug(`[PGliteInternal][worker-main] received 'leader-here' on broadcast channel`)\n        this.#connected = false\n        this.#eventTarget.dispatchEvent(new Event('leader-change'))\n        this.#leaderNotifyLoop()\n      } else if (event.data.type === 'notify') {\n        this.#receiveNotification(event.data.channel, event.data.payload)\n      }\n    })\n\n    this.#tabChannel.addEventListener('message', async (event) => {\n      if (event.data.type === 'connected') {\n        console.info(`[PGliteInternal][worker-main] ${stamp()} received 'connected' on tab channel - connection established!`)\n        this.#connected = true\n        this.#eventTarget.dispatchEvent(new Event('connected'))\n        this.#debug = await this.#rpc('getDebugLevel')\n        this.#ready = true\n        console.info(`[PGliteInternal][worker-main] ${stamp()} ready flag set, debug level=${this.#debug}`)\n      } else if (event.data.type === 'connection-error') {\n        // FIX 4 (2025-12-23): Handle connection failure due to health check\n        // This happens when the database is corrupted and fails a simple query\n        console.error(`[PGliteInternal][worker-main] ${stamp()} âŒ CONNECTION FAILED: ${event.data.error?.message}`)\n        console.error(`[PGliteInternal][worker-main] Database health check failed - database may be corrupted`)\n        console.error(`[PGliteInternal][worker-main] ðŸ’¡ Recovery: Clear site data and reload`)\n\n        // Dispatch an error event that the application can listen for\n        const errorEvent = new CustomEvent('connection-error', {\n          detail: {\n            code: event.data.error?.code || 'UNKNOWN',\n            message: event.data.error?.message || 'Connection failed'\n          }\n        })\n        this.#eventTarget.dispatchEvent(errorEvent)\n\n        // Also dispatch a generic 'error' event for backwards compatibility\n        this.#eventTarget.dispatchEvent(new ErrorEvent('error', {\n          message: event.data.error?.message || 'Database connection failed',\n          error: new Error(event.data.error?.message || 'Database connection failed')\n        }))\n      }\n    })\n\n    this.#workerProcess.addEventListener('message', async (event) => {\n      if (event.data.type === 'leader-now') {\n        console.info(`[PGliteInternal][worker-main] ${stamp()} received 'leader-now' - this tab is the leader`)\n        this.#isLeader = true\n        this.#eventTarget.dispatchEvent(new Event('leader-change'))\n      }\n    })\n\n    console.debug(`[PGliteInternal][worker-main] ${stamp()} starting leader notify loop`)\n    this.#leaderNotifyLoop()\n\n    // Init array types\n    // We don't await this as it will result in a deadlock\n    // It immediately takes out the transaction lock as so another query\n    console.debug(`[PGliteInternal][worker-main] ${stamp()} initiating _initArrayTypes() (not awaited)`)\n    this._initArrayTypes()\n\n    const totalElapsed = (_now() - t0).toFixed(1)\n    console.info(`[PGliteInternal][worker-main] ${stamp()} ========== PGliteWorker #init COMPLETE (total ${totalElapsed}ms) ==========`)\n  }\n\n  async #leaderNotifyLoop() {\n    if (!this.#connected) {\n      this.#broadcastChannel!.postMessage({\n        type: 'tab-here',\n        id: this.#tabId,\n      })\n      setTimeout(() => this.#leaderNotifyLoop(), 16)\n    }\n  }\n\n  async #rpc<Method extends WorkerRpcMethod>(\n    method: Method,\n    ...args: Parameters<WorkerApi[Method]>\n  ): Promise<ReturnType<WorkerApi[Method]>> {\n    const callId = uuid()\n    const message: WorkerRpcCall<Method> = {\n      type: 'rpc-call',\n      callId,\n      method,\n      args,\n    }\n    this.#tabChannel!.postMessage(message)\n    return await new Promise<ReturnType<WorkerApi[Method]>>(\n      (resolve, reject) => {\n        const listener = (event: MessageEvent) => {\n          if (event.data.callId !== callId) return\n          cleanup()\n          const message: WorkerRpcResponse<Method> = event.data\n          if (message.type === 'rpc-return') {\n            resolve(message.result)\n          } else if (message.type === 'rpc-error') {\n            const error = new Error(message.error.message)\n            Object.assign(error, message.error)\n            reject(error)\n          } else {\n            reject(new Error('Invalid message'))\n          }\n        }\n        const leaderChangeListener = () => {\n          // If the leader changes, throw an error to reject the promise\n          cleanup()\n          reject(new LeaderChangedError())\n        }\n        const cleanup = () => {\n          this.#tabChannel!.removeEventListener('message', listener)\n          this.#eventTarget.removeEventListener(\n            'leader-change',\n            leaderChangeListener,\n          )\n        }\n        this.#eventTarget.addEventListener(\n          'leader-change',\n          leaderChangeListener,\n        )\n        this.#tabChannel!.addEventListener('message', listener)\n      },\n    )\n  }\n\n  get waitReady() {\n    return new Promise<void>((resolve) => {\n      this.#initPromise.then(() => {\n        if (!this.#connected) {\n          resolve(\n            new Promise<void>((resolve) => {\n              this.#eventTarget.addEventListener('connected', () => {\n                resolve()\n              })\n            }),\n          )\n        } else {\n          resolve()\n        }\n      })\n    })\n  }\n\n  get debug() {\n    return this.#debug\n  }\n\n  /**\n   * The ready state of the database\n   */\n  get ready() {\n    return this.#ready\n  }\n\n  /**\n   * The closed state of the database\n   */\n  get closed() {\n    return this.#closed\n  }\n\n  /**\n   * The leader state of this tab\n   */\n  get isLeader() {\n    return this.#isLeader\n  }\n\n  /**\n   * Close the database\n   * @returns Promise that resolves when the connection to shared PGlite is closed\n   */\n  async close() {\n    if (this.#closed) {\n      return\n    }\n    this.#closed = true\n    this.#broadcastChannel?.close()\n    this.#tabChannel?.close()\n    this.#releaseTabCloseLock?.()\n    this.#workerProcess.terminate()\n  }\n\n  /**\n   * Close the database when the object exits scope\n   * Stage 3 ECMAScript Explicit Resource Management\n   * https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-2.html#using-declarations-and-explicit-resource-management\n   */\n  async [Symbol.asyncDispose]() {\n    await this.close()\n  }\n\n  /**\n   * Execute a postgres wire protocol message directly without wrapping the response.\n   * Only use if `execProtocol()` doesn't suite your needs.\n   *\n   * **Warning:** This bypasses PGlite's protocol wrappers that manage error/notice messages,\n   * transactions, and notification listeners. Only use if you need to bypass these wrappers and\n   * don't intend to use the above features.\n   *\n   * @param message The postgres wire protocol message to execute\n   * @returns The direct message data response produced by Postgres\n   */\n  async execProtocolRaw(message: Uint8Array): Promise<Uint8Array> {\n    return (await this.#rpc('execProtocolRaw', message)) as Uint8Array\n  }\n\n  /**\n   * Execute a postgres wire protocol message\n   * @param message The postgres wire protocol message to execute\n   * @returns The result of the query\n   */\n  async execProtocol(message: Uint8Array): Promise<ExecProtocolResult> {\n    return await this.#rpc('execProtocol', message)\n  }\n\n  /**\n   * Execute a postgres wire protocol message\n   * @param message The postgres wire protocol message to execute\n   * @returns The result of the query\n   */\n  async execProtocolStream(message: Uint8Array): Promise<BackendMessage[]> {\n    return await this.#rpc('execProtocolStream', message)\n  }\n\n  /**\n   * Sync the database to the filesystem\n   * @returns Promise that resolves when the database is synced to the filesystem\n   */\n  async syncToFs() {\n    await this.#rpc('syncToFs')\n  }\n\n  /**\n   * Listen for a notification\n   * @param channel The channel to listen on\n   * @param callback The callback to call when a notification is received\n   */\n  async listen(\n    channel: string,\n    callback: (payload: string) => void,\n    tx?: Transaction,\n  ): Promise<() => Promise<void>> {\n    const pgChannel = toPostgresName(channel)\n    const pg = tx ?? this\n    if (!this.#notifyListeners.has(pgChannel)) {\n      this.#notifyListeners.set(pgChannel, new Set())\n    }\n    this.#notifyListeners.get(pgChannel)!.add(callback)\n    await pg.exec(`LISTEN ${channel}`)\n    return async (tx?: Transaction) => {\n      await this.unlisten(pgChannel, callback, tx)\n    }\n  }\n\n  /**\n   * Stop listening for a notification\n   * @param channel The channel to stop listening on\n   * @param callback The callback to remove\n   */\n  async unlisten(\n    channel: string,\n    callback?: (payload: string) => void,\n    tx?: Transaction,\n  ): Promise<void> {\n    await this.waitReady\n    const pg = tx ?? this\n    if (callback) {\n      this.#notifyListeners.get(channel)?.delete(callback)\n    } else {\n      this.#notifyListeners.delete(channel)\n    }\n    if (this.#notifyListeners.get(channel)?.size === 0) {\n      // As we currently have a dedicated worker we can just unlisten\n      await pg.exec(`UNLISTEN ${channel}`)\n    }\n  }\n\n  /**\n   * Listen to notifications\n   * @param callback The callback to call when a notification is received\n   */\n  onNotification(callback: (channel: string, payload: string) => void) {\n    this.#globalNotifyListeners.add(callback)\n    return () => {\n      this.#globalNotifyListeners.delete(callback)\n    }\n  }\n\n  /**\n   * Stop listening to notifications\n   * @param callback The callback to remove\n   */\n  offNotification(callback: (channel: string, payload: string) => void) {\n    this.#globalNotifyListeners.delete(callback)\n  }\n\n  #receiveNotification(channel: string, payload: string) {\n    const listeners = this.#notifyListeners.get(channel)\n    if (listeners) {\n      for (const listener of listeners) {\n        queueMicrotask(() => listener(payload))\n      }\n    }\n    for (const listener of this.#globalNotifyListeners) {\n      queueMicrotask(() => listener(channel, payload))\n    }\n  }\n\n  async dumpDataDir(\n    compression?: DumpTarCompressionOptions,\n  ): Promise<File | Blob> {\n    return (await this.#rpc('dumpDataDir', compression)) as File | Blob\n  }\n\n  onLeaderChange(callback: () => void) {\n    this.#eventTarget.addEventListener('leader-change', callback)\n    return () => {\n      this.#eventTarget.removeEventListener('leader-change', callback)\n    }\n  }\n\n  offLeaderChange(callback: () => void) {\n    this.#eventTarget.removeEventListener('leader-change', callback)\n  }\n\n  async _handleBlob(blob?: File | Blob): Promise<void> {\n    await this.#rpc('_handleBlob', blob)\n  }\n\n  async _getWrittenBlob(): Promise<File | Blob | undefined> {\n    return await this.#rpc('_getWrittenBlob')\n  }\n\n  async _cleanupBlob(): Promise<void> {\n    await this.#rpc('_cleanupBlob')\n  }\n\n  async _checkReady() {\n    await this.waitReady\n  }\n\n  async _runExclusiveQuery<T>(fn: () => Promise<T>): Promise<T> {\n    await this.#rpc('_acquireQueryLock')\n    try {\n      return await fn()\n    } finally {\n      await this.#rpc('_releaseQueryLock')\n    }\n  }\n\n  async _runExclusiveTransaction<T>(fn: () => Promise<T>): Promise<T> {\n    await this.#rpc('_acquireTransactionLock')\n    try {\n      return await fn()\n    } finally {\n      await this.#rpc('_releaseTransactionLock')\n    }\n  }\n}\n\nexport interface WorkerOptions {\n  init: (options: Exclude<PGliteWorkerOptions, 'extensions'>) => Promise<PGlite>\n}\n\nexport async function worker({ init }: WorkerOptions) {\n  // =============================================================================\n  // DIAGNOSTIC LOGGING (Phase 1 - worker thread side)\n  // =============================================================================\n  const _now = () => (typeof performance !== 'undefined' && performance.now ? performance.now() : Date.now())\n  const t0 = _now()\n  const stamp = () => `+${(_now() - t0).toFixed(1)}ms`\n\n  console.info(`[PGliteInternal][worker-thread] ${stamp()} ========== worker() START ==========`)\n\n  // Send a message to the main thread to let it know we are here\n  console.debug(`[PGliteInternal][worker-thread] ${stamp()} posting 'here' message to main thread`)\n  postMessage({ type: 'here' })\n\n  // Await the main thread to send us the options\n  console.debug(`[PGliteInternal][worker-thread] ${stamp()} waiting for 'init' message from main thread...`)\n  const initWaitStart = _now()\n  const options = await new Promise<Exclude<PGliteWorkerOptions, 'extensions'>>(\n    (resolve) => {\n      addEventListener(\n        'message',\n        (event) => {\n          if (event.data.type === 'init') {\n            resolve(event.data.options)\n          }\n        },\n        { once: true },\n      )\n    },\n  )\n  console.info(`[PGliteInternal][worker-thread] ${stamp()} received 'init' message (waited ${(_now() - initWaitStart).toFixed(1)}ms, dataDir=${options.dataDir ?? 'memory://'})`)\n\n  // ID for this multi-tab worker - this is used to identify the group of workers\n  // that are trying to elect a leader for a shared PGlite instance.\n  // It defaults to the URL of the worker, and the dataDir if provided\n  // but can be overridden by the options.\n  const id = options.id ?? `${import.meta.url}:${options.dataDir ?? ''}`\n  console.debug(`[PGliteInternal][worker-thread] ${stamp()} worker id=${id}`)\n\n  // Let the main thread know we are ready\n  console.debug(`[PGliteInternal][worker-thread] ${stamp()} posting 'ready' message to main thread`)\n  postMessage({ type: 'ready', id })\n\n  const electionLockId = `pglite-election-lock:${id}`\n  const broadcastChannelId = `pglite-broadcast:${id}`\n  const broadcastChannel = new BroadcastChannel(broadcastChannelId)\n  const connectedTabs = new Set<string>()\n  console.debug(`[PGliteInternal][worker-thread] ${stamp()} broadcast channel created: ${broadcastChannelId}`)\n\n  // Await the main lock which is used to elect the leader\n  // We don't release this lock, its automatically released when the worker or\n  // tab is closed\n  console.debug(`[PGliteInternal][worker-thread] ${stamp()} acquiring election lock: ${electionLockId}...`)\n  const lockWaitStart = _now()\n  await acquireLock(electionLockId)\n  console.info(`[PGliteInternal][worker-thread] ${stamp()} election lock acquired - THIS WORKER IS NOW LEADER (waited ${(_now() - lockWaitStart).toFixed(1)}ms)`)\n\n  // Now we are the leader, start the worker\n  console.debug(`[PGliteInternal][worker-thread] ${stamp()} calling init(options) to create PGlite instance...`)\n  const dbInitStart = _now()\n  const dbPromise = init(options)\n\n  // Start listening for messages from tabs\n  broadcastChannel.onmessage = async (event) => {\n    const msg = event.data\n    switch (msg.type) {\n      case 'tab-here':\n        // A new tab has joined,\n        console.debug(`[PGliteInternal][worker-thread] received 'tab-here' from tab ${msg.id}`)\n        connectTab(msg.id, await dbPromise, connectedTabs)\n        break\n    }\n  }\n\n  // Notify the other tabs that we are the leader\n  console.debug(`[PGliteInternal][worker-thread] ${stamp()} posting 'leader-here' to broadcast channel`)\n  broadcastChannel.postMessage({ type: 'leader-here', id })\n\n  // Let the main thread know we are the leader\n  console.debug(`[PGliteInternal][worker-thread] ${stamp()} posting 'leader-now' to main thread`)\n  postMessage({ type: 'leader-now' })\n\n  console.debug(`[PGliteInternal][worker-thread] ${stamp()} awaiting dbPromise (PGlite initialization)...`)\n  const db = await dbPromise\n  console.info(`[PGliteInternal][worker-thread] ${stamp()} dbPromise resolved - PGlite instance ready (took ${(_now() - dbInitStart).toFixed(1)}ms)`)\n\n  // Listen for notifications and broadcast them to all tabs\n  db.onNotification((channel, payload) => {\n    broadcastChannel.postMessage({ type: 'notify', channel, payload })\n  })\n\n  const totalElapsed = (_now() - t0).toFixed(1)\n  console.info(`[PGliteInternal][worker-thread] ${stamp()} ========== worker() COMPLETE (total ${totalElapsed}ms) ==========`)\n}\n\n// Track first RPC call for diagnostic purposes\nlet firstRpcHandled = false\n\nasync function connectTab(tabId: string, pg: PGlite, connectedTabs: Set<string>) {\n  const _now = () => (typeof performance !== 'undefined' && performance.now ? performance.now() : Date.now())\n\n  if (connectedTabs.has(tabId)) {\n    console.debug(`[PGliteInternal][worker-thread] connectTab: tab ${tabId} already connected, skipping`)\n    return\n  }\n\n  console.debug(`[PGliteInternal][worker-thread] connectTab: connecting tab ${tabId}`)\n  connectedTabs.add(tabId)\n  const tabChannelId = `pglite-tab:${tabId}`\n  const tabCloseLockId = `pglite-tab-close:${tabId}`\n  const tabChannel = new BroadcastChannel(tabChannelId)\n\n  // Use a tab close lock to unsubscribe the tab\n  navigator.locks.request(tabCloseLockId, () => {\n    return new Promise<void>((resolve) => {\n      // The tab has been closed, unsubscribe the tab broadcast channel\n      console.debug(`[PGliteInternal][worker-thread] tab ${tabId} closed, cleaning up`)\n      tabChannel.close()\n      connectedTabs.delete(tabId)\n      resolve()\n    })\n  })\n\n  const api = makeWorkerApi(tabId, pg)\n\n  tabChannel.addEventListener('message', async (event) => {\n    const msg = event.data\n    switch (msg.type) {\n      case 'rpc-call': {\n        const rpcStart = _now()\n        const { callId, method, args } = msg as WorkerRpcCall<WorkerRpcMethod>\n\n        // Log first RPC call as a milestone\n        if (!firstRpcHandled) {\n          console.info(`[PGliteInternal][worker-thread] FIRST RPC CALL: method=${method}, callId=${callId}`)\n        }\n\n        await pg.waitReady\n\n        try {\n          // @ts-ignore no apparent reason why it fails\n          const result = (await api[method](...args)) as WorkerRpcResult<\n            typeof method\n          >['result']\n          tabChannel.postMessage({\n            type: 'rpc-return',\n            callId,\n            result,\n          } satisfies WorkerRpcResult<typeof method>)\n\n          if (!firstRpcHandled) {\n            console.info(`[PGliteInternal][worker-thread] FIRST RPC CALL COMPLETE: method=${method}, took ${(_now() - rpcStart).toFixed(1)}ms`)\n            firstRpcHandled = true\n          }\n        } catch (error) {\n          console.error(error)\n          tabChannel.postMessage({\n            type: 'rpc-error',\n            callId,\n            error: { message: (error as Error).message },\n          } satisfies WorkerRpcError)\n        }\n        break\n      }\n    }\n  })\n\n  // FIX 4 (2025-12-23): Validate database health before sending 'connected'\n  // This prevents connecting to a corrupted database that appears \"ready\" but\n  // will fail on actual queries with I/O errors like \"Operation canceled\"\n  const healthCheckStart = _now()\n  try {\n    // Wait for database to be fully ready\n    await pg.waitReady\n\n    // Perform a simple health check query\n    // This catches corruption that manifests as I/O errors on database files\n    await pg.query('SELECT 1 as health_check')\n\n    const healthCheckMs = (_now() - healthCheckStart).toFixed(1)\n    console.debug(`[PGliteInternal][worker-thread] health check passed for tab ${tabId} (${healthCheckMs}ms)`)\n\n    // Send a message to the tab to let it know it's connected\n    console.debug(`[PGliteInternal][worker-thread] posting 'connected' to tab ${tabId}`)\n    tabChannel.postMessage({ type: 'connected' })\n  } catch (healthError: any) {\n    // Health check failed - database is corrupted or I/O errors\n    console.error(`[PGliteInternal][worker-thread] âŒ Health check FAILED for tab ${tabId}:`, healthError)\n    console.error(`[PGliteInternal][worker-thread] Database may be corrupted. Error: ${healthError.message}`)\n\n    // Remove from connected tabs since we're not actually connected\n    connectedTabs.delete(tabId)\n\n    // Notify the tab of the connection failure\n    tabChannel.postMessage({\n      type: 'connection-error',\n      error: {\n        message: `Database health check failed: ${healthError.message}`,\n        code: 'HEALTH_CHECK_FAILED'\n      }\n    })\n\n    // Clean up the tab channel\n    tabChannel.close()\n  }\n}\n\nfunction makeWorkerApi(tabId: string, db: PGlite) {\n  let queryLockRelease: (() => void) | null = null\n  let transactionLockRelease: (() => void) | null = null\n\n  // If the tab is closed and it is holding a lock, release the the locks\n  // and rollback any pending transactions\n  const tabCloseLockId = `pglite-tab-close:${tabId}`\n  acquireLock(tabCloseLockId).then(() => {\n    if (transactionLockRelease) {\n      // rollback any pending transactions\n      db.exec('ROLLBACK')\n    }\n    queryLockRelease?.()\n    transactionLockRelease?.()\n  })\n\n  return {\n    async getDebugLevel() {\n      return db.debug\n    },\n    async close() {\n      await db.close()\n    },\n    async execProtocol(message: Uint8Array) {\n      const { messages, data } = await db.execProtocol(message)\n      if (data.byteLength !== data.buffer.byteLength) {\n        const buffer = new ArrayBuffer(data.byteLength)\n        const dataCopy = new Uint8Array(buffer)\n        dataCopy.set(data)\n        return { messages, data: dataCopy }\n      } else {\n        return { messages, data }\n      }\n    },\n    async execProtocolStream(message: Uint8Array) {\n      const messages = await db.execProtocolStream(message)\n      return messages\n    },\n    async execProtocolRaw(message: Uint8Array) {\n      const result = await db.execProtocolRaw(message)\n      if (result.byteLength !== result.buffer.byteLength) {\n        // The data is a slice of a larger buffer, this is potentially the whole\n        // memory of the WASM module. We copy it to a new Uint8Array and return that.\n        const buffer = new ArrayBuffer(result.byteLength)\n        const resultCopy = new Uint8Array(buffer)\n        resultCopy.set(result)\n        return resultCopy\n      } else {\n        return result\n      }\n    },\n    async dumpDataDir(compression?: DumpTarCompressionOptions) {\n      return await db.dumpDataDir(compression)\n    },\n    async syncToFs() {\n      return await db.syncToFs()\n    },\n    async _handleBlob(blob?: File | Blob) {\n      return await db._handleBlob(blob)\n    },\n    async _getWrittenBlob() {\n      return await db._getWrittenBlob()\n    },\n    async _cleanupBlob() {\n      return await db._cleanupBlob()\n    },\n    async _checkReady() {\n      return await db._checkReady()\n    },\n    async _acquireQueryLock() {\n      return new Promise<void>((resolve) => {\n        db._runExclusiveQuery(() => {\n          return new Promise<void>((release) => {\n            queryLockRelease = release\n            resolve()\n          })\n        })\n      })\n    },\n    async _releaseQueryLock() {\n      queryLockRelease?.()\n      queryLockRelease = null\n    },\n    async _acquireTransactionLock() {\n      return new Promise<void>((resolve) => {\n        db._runExclusiveTransaction(() => {\n          return new Promise<void>((release) => {\n            transactionLockRelease = release\n            resolve()\n          })\n        })\n      })\n    },\n    async _releaseTransactionLock() {\n      transactionLockRelease?.()\n      transactionLockRelease = null\n    },\n  }\n}\n\nexport class LeaderChangedError extends Error {\n  constructor() {\n    super('Leader changed, pending operation in indeterminate state')\n  }\n}\n\nasync function acquireLock(lockId: string) {\n  let release\n  await new Promise<void>((resolve) => {\n    navigator.locks.request(lockId, () => {\n      return new Promise<void>((releaseCallback) => {\n        release = releaseCallback\n        resolve()\n      })\n    })\n  })\n  return release\n}\n\ntype WorkerApi = ReturnType<typeof makeWorkerApi>\n\ntype WorkerRpcMethod = keyof WorkerApi\n\ntype WorkerRpcCall<Method extends WorkerRpcMethod> = {\n  type: 'rpc-call'\n  callId: string\n  method: Method\n  args: Parameters<WorkerApi[Method]>\n}\n\ntype WorkerRpcResult<Method extends WorkerRpcMethod> = {\n  type: 'rpc-return'\n  callId: string\n  result: ReturnType<WorkerApi[Method]>\n}\n\ntype WorkerRpcError = {\n  type: 'rpc-error'\n  callId: string\n  error: any\n}\n\ntype WorkerRpcResponse<Method extends WorkerRpcMethod> =\n  | WorkerRpcResult<Method>\n  | WorkerRpcError\n"],"mappings":"2LAAAA,IAAA,IAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,GAAAC,EAAAC,EAAAC,GAqBaC,EAAN,MAAMA,UACHC,CAEV,CA6BE,YAAYC,EAAgBC,EAA+B,CACzD,MAAM,EAjCHC,EAAA,KAAAT,GAILS,EAAA,KAAA5B,GACA4B,EAAA,KAAA3B,EAAqB,GAErB2B,EAAA,KAAA1B,EAAS,IACT0B,EAAA,KAAAzB,EAAU,IACVyB,EAAA,KAAAxB,EAAY,IAEZwB,EAAA,KAAAvB,EAAe,IAAI,aAEnBuB,EAAA,KAAAtB,GAEAsB,EAAA,KAAArB,EAAa,IAEbqB,EAAA,KAAApB,GACAoB,EAAA,KAAAnB,GACAmB,EAAA,KAAAlB,GACAkB,EAAA,KAAAjB,GAEAiB,EAAA,KAAAhB,GACAgB,EAAA,KAAAf,GACAe,EAAA,KAAAd,GAEAc,EAAA,KAAAb,EAAmB,IAAI,KACvBa,EAAA,KAAAZ,EAAyB,IAAI,KAE7BY,EAAA,KAAAX,GACAW,EAAA,KAAAV,EAA+C,CAAC,GAI9CW,EAAA,KAAKrB,EAAiBkB,GACtBG,EAAA,KAAKvB,EAASwB,EAAK,GACnBD,EAAA,KAAKZ,EAAcU,GAAS,YAAc,CAAC,GAE3CE,EAAA,KAAKnB,EAAqB,IAAI,QAAeqB,GAAY,CACvDC,EAAA,KAAKxB,GAAe,iBAClB,UACCyB,GAAU,CACT,GAAIA,EAAM,KAAK,OAAS,OACtBF,EAAQ,MAER,OAAM,IAAI,MAAM,iBAAiB,CAErC,EACA,CAAE,KAAM,EAAK,CACf,CACF,CAAC,GAEDF,EAAA,KAAKlB,EAAsB,IAAI,QAAeoB,GAAY,CACxD,IAAMG,EAAYD,GAA6B,CACzCA,EAAM,KAAK,OAAS,UACtBJ,EAAA,KAAKpB,EAAYwB,EAAM,KAAK,IAC5BD,EAAA,KAAKxB,GAAe,oBAAoB,UAAW0B,CAAQ,EAC3DH,EAAQ,EAEZ,EACAC,EAAA,KAAKxB,GAAe,iBAAiB,UAAW0B,CAAQ,CAC1D,CAAC,GAEDL,EAAA,KAAK7B,EAAemC,EAAA,KAAKhB,EAAAC,IAAL,UAAWO,GACjC,CAWA,aAAa,OACXD,EACAC,EACoE,CACpE,IAAMS,EAAK,IAAIZ,EAAaE,EAAQC,CAAO,EAC3C,aAAMK,EAAAI,EAAGpC,GACFoC,CACT,CAiNA,IAAI,WAAY,CACd,OAAO,IAAI,QAAeL,GAAY,CACpCC,EAAA,KAAKhC,GAAa,KAAK,IAAM,CACtBgC,EAAA,KAAKzB,GASRwB,EAAQ,EARRA,EACE,IAAI,QAAeA,GAAY,CAC7BC,EAAA,KAAK3B,GAAa,iBAAiB,YAAa,IAAM,CACpD0B,EAAQ,CACV,CAAC,CACH,CAAC,CACH,CAIJ,CAAC,CACH,CAAC,CACH,CAEA,IAAI,OAAQ,CACV,OAAOC,EAAA,KAAK/B,EACd,CAKA,IAAI,OAAQ,CACV,OAAO+B,EAAA,KAAK9B,EACd,CAKA,IAAI,QAAS,CACX,OAAO8B,EAAA,KAAK7B,EACd,CAKA,IAAI,UAAW,CACb,OAAO6B,EAAA,KAAK5B,EACd,CAMA,MAAM,OAAQ,CAvWhB,IAAAiC,EAwWQL,EAAA,KAAK7B,KAGT0B,EAAA,KAAK1B,EAAU,IACf6B,EAAA,KAAKpB,IAAmB,MAAM,EAC9BoB,EAAA,KAAKnB,IAAa,MAAM,GACxBwB,EAAAL,EAAA,KAAKlB,KAAL,MAAAuB,EAAA,WACAL,EAAA,KAAKxB,GAAe,UAAU,EAChC,CAOA,MAAO,OAAO,YAAY,GAAI,CAC5B,MAAM,KAAK,MAAM,CACnB,CAaA,MAAM,gBAAgB8B,EAA0C,CAC9D,OAAQ,MAAMH,EAAA,KAAKhB,EAAAG,GAAL,UAAU,kBAAmBgB,EAC7C,CAOA,MAAM,aAAaA,EAAkD,CACnE,OAAO,MAAMH,EAAA,KAAKhB,EAAAG,GAAL,UAAU,eAAgBgB,EACzC,CAOA,MAAM,mBAAmBA,EAAgD,CACvE,OAAO,MAAMH,EAAA,KAAKhB,EAAAG,GAAL,UAAU,qBAAsBgB,EAC/C,CAMA,MAAM,UAAW,CACf,MAAMH,EAAA,KAAKhB,EAAAG,GAAL,UAAU,WAClB,CAOA,MAAM,OACJiB,EACAL,EACAM,EAC8B,CAC9B,IAAMC,EAAYC,EAAeH,CAAO,EAClCH,EAAKI,GAAM,KACjB,OAAKR,EAAA,KAAKjB,GAAiB,IAAI0B,CAAS,GACtCT,EAAA,KAAKjB,GAAiB,IAAI0B,EAAW,IAAI,GAAK,EAEhDT,EAAA,KAAKjB,GAAiB,IAAI0B,CAAS,EAAG,IAAIP,CAAQ,EAClD,MAAME,EAAG,KAAK,UAAUG,CAAO,EAAE,EAC1B,MAAOC,GAAqB,CACjC,MAAM,KAAK,SAASC,EAAWP,EAAUM,CAAE,CAC7C,CACF,CAOA,MAAM,SACJD,EACAL,EACAM,EACe,CACf,MAAM,KAAK,UACX,IAAMJ,EAAKI,GAAM,KACbN,EACFF,EAAA,KAAKjB,GAAiB,IAAIwB,CAAO,GAAG,OAAOL,CAAQ,EAEnDF,EAAA,KAAKjB,GAAiB,OAAOwB,CAAO,EAElCP,EAAA,KAAKjB,GAAiB,IAAIwB,CAAO,GAAG,OAAS,GAE/C,MAAMH,EAAG,KAAK,YAAYG,CAAO,EAAE,CAEvC,CAMA,eAAeL,EAAsD,CACnE,OAAAF,EAAA,KAAKhB,GAAuB,IAAIkB,CAAQ,EACjC,IAAM,CACXF,EAAA,KAAKhB,GAAuB,OAAOkB,CAAQ,CAC7C,CACF,CAMA,gBAAgBA,EAAsD,CACpEF,EAAA,KAAKhB,GAAuB,OAAOkB,CAAQ,CAC7C,CAcA,MAAM,YACJS,EACsB,CACtB,OAAQ,MAAMR,EAAA,KAAKhB,EAAAG,GAAL,UAAU,cAAeqB,EACzC,CAEA,eAAeT,EAAsB,CACnC,OAAAF,EAAA,KAAK3B,GAAa,iBAAiB,gBAAiB6B,CAAQ,EACrD,IAAM,CACXF,EAAA,KAAK3B,GAAa,oBAAoB,gBAAiB6B,CAAQ,CACjE,CACF,CAEA,gBAAgBA,EAAsB,CACpCF,EAAA,KAAK3B,GAAa,oBAAoB,gBAAiB6B,CAAQ,CACjE,CAEA,MAAM,YAAYU,EAAmC,CACnD,MAAMT,EAAA,KAAKhB,EAAAG,GAAL,UAAU,cAAesB,EACjC,CAEA,MAAM,iBAAoD,CACxD,OAAO,MAAMT,EAAA,KAAKhB,EAAAG,GAAL,UAAU,kBACzB,CAEA,MAAM,cAA8B,CAClC,MAAMa,EAAA,KAAKhB,EAAAG,GAAL,UAAU,eAClB,CAEA,MAAM,aAAc,CAClB,MAAM,KAAK,SACb,CAEA,MAAM,mBAAsBuB,EAAkC,CAC5D,MAAMV,EAAA,KAAKhB,EAAAG,GAAL,UAAU,qBAChB,GAAI,CACF,OAAO,MAAMuB,EAAG,CAClB,QAAE,CACA,MAAMV,EAAA,KAAKhB,EAAAG,GAAL,UAAU,oBAClB,CACF,CAEA,MAAM,yBAA4BuB,EAAkC,CAClE,MAAMV,EAAA,KAAKhB,EAAAG,GAAL,UAAU,2BAChB,GAAI,CACF,OAAO,MAAMuB,EAAG,CAClB,QAAE,CACA,MAAMV,EAAA,KAAKhB,EAAAG,GAAL,UAAU,0BAClB,CACF,CACF,EAzgBEtB,EAAA,YACAC,EAAA,YAEAC,EAAA,YACAC,EAAA,YACAC,EAAA,YAEAC,EAAA,YAEAC,EAAA,YAEAC,EAAA,YAEAC,EAAA,YACAC,EAAA,YACAC,EAAA,YACAC,EAAA,YAEAC,EAAA,YACAC,EAAA,YACAC,EAAA,YAEAC,EAAA,YACAC,EAAA,YAEAC,EAAA,YACAC,EAAA,YA9BKC,EAAA,YAoFCC,GAAK,eAACO,EAA+B,CAAC,EAAG,CAI7C,IAAMmB,EAAO,IAAO,OAAO,YAAgB,KAAe,YAAY,IAAM,YAAY,IAAI,EAAI,KAAK,IAAI,EACnGC,EAAKD,EAAK,EACVE,EAAQ,IAAM,KAAKF,EAAK,EAAIC,GAAI,QAAQ,CAAC,CAAC,KAEhD,QAAQ,KAAK,iCAAiCC,EAAM,CAAC,iDAAiD,EACtG,QAAQ,MAAM,iCAAiCA,EAAM,CAAC,UAAUhB,EAAA,KAAK1B,EAAM,aAAaqB,EAAQ,SAAW,WAAW,EAAE,EAGxH,IAAMsB,EAAiB,OAAO,KAAKjB,EAAA,KAAKf,EAAW,EAAE,OACrD,QAAQ,MAAM,iCAAiC+B,EAAM,CAAC,eAAeC,CAAc,iCAAiC,EACpH,IAAMC,EAAgBJ,EAAK,EAC3B,OAAW,CAACK,EAASC,CAAG,IAAK,OAAO,QAAQpB,EAAA,KAAKf,EAAW,EAAG,CAC7D,GAAImC,aAAe,IACjB,MAAM,IAAI,MACR,iEACF,EACK,CACL,IAAMC,EAAS,MAAMD,EAAI,MAAM,KAAM,CAAC,EAAG,EAAI,EAM7C,GALIC,EAAO,gBACT,QAAQ,KACN,oBAAoBF,CAAO,kFAC7B,EAEEE,EAAO,aAAc,CACvB,IAAMC,GAAW,KACjBA,GAASH,CAAO,EAAIE,EAAO,YAC7B,CACIA,EAAO,YACT,QAAQ,KACN,oBAAoBF,CAAO,4EAC7B,EAEEE,EAAO,MACT,MAAMA,EAAO,KAAK,EAEhBA,EAAO,OACTrB,EAAA,KAAKd,GAAiB,KAAKmC,EAAO,KAAK,CAE3C,CACF,CACA,QAAQ,MAAM,iCAAiCL,EAAM,CAAC,sCAAsCF,EAAK,EAAII,GAAe,QAAQ,CAAC,CAAC,KAAK,EAGnI,QAAQ,MAAM,iCAAiCF,EAAM,CAAC,oEAAoE,EAC1H,IAAMO,EAAgBT,EAAK,EAC3B,MAAMd,EAAA,KAAKtB,GACX,QAAQ,KAAK,iCAAiCsC,EAAM,CAAC,wCAAwCF,EAAK,EAAIS,GAAe,QAAQ,CAAC,CAAC,KAAK,EAGpI,GAAM,CAAE,WAAYC,EAAG,GAAGC,CAAc,EAAI9B,EAC5C,QAAQ,MAAM,iCAAiCqB,EAAM,CAAC,gDAAgD,EACtGhB,EAAA,KAAKxB,GAAe,YAAY,CAC9B,KAAM,OACN,QAASiD,CACX,CAAC,EAGD,QAAQ,MAAM,iCAAiCT,EAAM,CAAC,sEAAsE,EAC5H,IAAMU,EAAiBZ,EAAK,EAC5B,MAAMd,EAAA,KAAKrB,GACX,QAAQ,KAAK,iCAAiCqC,EAAM,CAAC,yCAAyCF,EAAK,EAAIY,GAAgB,QAAQ,CAAC,CAAC,gBAAgB1B,EAAA,KAAKvB,EAAS,GAAG,EAIlK,IAAMkD,EAAiB,oBAAoB3B,EAAA,KAAK1B,EAAM,GACtD,QAAQ,MAAM,iCAAiC0C,EAAM,CAAC,8BAA8BW,CAAc,EAAE,EACpG,IAAMC,EAAed,EAAK,EAC1BjB,EAAA,KAAKf,EAAuB,MAAM+C,EAAYF,CAAc,GAC5D,QAAQ,MAAM,iCAAiCX,EAAM,CAAC,mCAAmCF,EAAK,EAAIc,GAAc,QAAQ,CAAC,CAAC,KAAK,EAG/H,IAAME,EAAqB,oBAAoB9B,EAAA,KAAKvB,EAAS,GAC7DoB,EAAA,KAAKjB,EAAoB,IAAI,iBAAiBkD,CAAkB,GAChE,QAAQ,MAAM,iCAAiCd,EAAM,CAAC,+BAA+Bc,CAAkB,EAAE,EAGzG,IAAMC,EAAe,cAAc/B,EAAA,KAAK1B,EAAM,GAC9CuB,EAAA,KAAKhB,EAAc,IAAI,iBAAiBkD,CAAY,GACpD,QAAQ,MAAM,iCAAiCf,EAAM,CAAC,yBAAyBe,CAAY,EAAE,EAE7F/B,EAAA,KAAKpB,GAAkB,iBAAiB,UAAW,MAAOqB,GAAU,CAC9DA,EAAM,KAAK,OAAS,eACtB,QAAQ,MAAM,2EAA2E,EACzFJ,EAAA,KAAKtB,EAAa,IAClByB,EAAA,KAAK3B,GAAa,cAAc,IAAI,MAAM,eAAe,CAAC,EAC1D8B,EAAA,KAAKhB,EAAAE,GAAL,YACSY,EAAM,KAAK,OAAS,UAC7BE,EAAA,KAAKhB,EAAAI,IAAL,UAA0BU,EAAM,KAAK,QAASA,EAAM,KAAK,QAE7D,CAAC,EAEDD,EAAA,KAAKnB,GAAY,iBAAiB,UAAW,MAAOoB,GAAU,CAC5D,GAAIA,EAAM,KAAK,OAAS,YACtB,QAAQ,KAAK,iCAAiCe,EAAM,CAAC,gEAAgE,EACrHnB,EAAA,KAAKtB,EAAa,IAClByB,EAAA,KAAK3B,GAAa,cAAc,IAAI,MAAM,WAAW,CAAC,EACtDwB,EAAA,KAAK5B,EAAS,MAAMkC,EAAA,KAAKhB,EAAAG,GAAL,UAAU,kBAC9BO,EAAA,KAAK3B,EAAS,IACd,QAAQ,KAAK,iCAAiC8C,EAAM,CAAC,gCAAgChB,EAAA,KAAK/B,EAAM,EAAE,UACzFgC,EAAM,KAAK,OAAS,mBAAoB,CAGjD,QAAQ,MAAM,iCAAiCe,EAAM,CAAC,8BAAyBf,EAAM,KAAK,OAAO,OAAO,EAAE,EAC1G,QAAQ,MAAM,wFAAwF,EACtG,QAAQ,MAAM,8EAAuE,EAGrF,IAAM+B,EAAa,IAAI,YAAY,mBAAoB,CACrD,OAAQ,CACN,KAAM/B,EAAM,KAAK,OAAO,MAAQ,UAChC,QAASA,EAAM,KAAK,OAAO,SAAW,mBACxC,CACF,CAAC,EACDD,EAAA,KAAK3B,GAAa,cAAc2D,CAAU,EAG1ChC,EAAA,KAAK3B,GAAa,cAAc,IAAI,WAAW,QAAS,CACtD,QAAS4B,EAAM,KAAK,OAAO,SAAW,6BACtC,MAAO,IAAI,MAAMA,EAAM,KAAK,OAAO,SAAW,4BAA4B,CAC5E,CAAC,CAAC,CACJ,CACF,CAAC,EAEDD,EAAA,KAAKxB,GAAe,iBAAiB,UAAW,MAAOyB,GAAU,CAC3DA,EAAM,KAAK,OAAS,eACtB,QAAQ,KAAK,iCAAiCe,EAAM,CAAC,iDAAiD,EACtGnB,EAAA,KAAKzB,EAAY,IACjB4B,EAAA,KAAK3B,GAAa,cAAc,IAAI,MAAM,eAAe,CAAC,EAE9D,CAAC,EAED,QAAQ,MAAM,iCAAiC2C,EAAM,CAAC,8BAA8B,EACpFb,EAAA,KAAKhB,EAAAE,GAAL,WAKA,QAAQ,MAAM,iCAAiC2B,EAAM,CAAC,6CAA6C,EACnG,KAAK,gBAAgB,EAErB,IAAMiB,GAAgBnB,EAAK,EAAIC,GAAI,QAAQ,CAAC,EAC5C,QAAQ,KAAK,iCAAiCC,EAAM,CAAC,kDAAkDiB,CAAY,gBAAgB,CACrI,EAEM5C,EAAiB,gBAAG,CACnBW,EAAA,KAAKzB,KACRyB,EAAA,KAAKpB,GAAmB,YAAY,CAClC,KAAM,WACN,GAAIoB,EAAA,KAAK1B,EACX,CAAC,EACD,WAAW,IAAM6B,EAAA,KAAKhB,EAAAE,GAAL,WAA0B,EAAE,EAEjD,EAEMC,EAAoC,eACxC4C,KACGC,EACqC,CACxC,IAAMC,EAAStC,EAAK,EACdQ,EAAiC,CACrC,KAAM,WACN,OAAA8B,EACA,OAAAF,EACA,KAAAC,CACF,EACA,OAAAnC,EAAA,KAAKnB,GAAa,YAAYyB,CAAO,EAC9B,MAAM,IAAI,QACf,CAACP,EAASsC,IAAW,CACnB,IAAMC,EAAYrC,GAAwB,CACxC,GAAIA,EAAM,KAAK,SAAWmC,EAAQ,OAClCG,EAAQ,EACR,IAAMjC,EAAqCL,EAAM,KACjD,GAAIK,EAAQ,OAAS,aACnBP,EAAQO,EAAQ,MAAM,UACbA,EAAQ,OAAS,YAAa,CACvC,IAAMkC,EAAQ,IAAI,MAAMlC,EAAQ,MAAM,OAAO,EAC7C,OAAO,OAAOkC,EAAOlC,EAAQ,KAAK,EAClC+B,EAAOG,CAAK,CACd,MACEH,EAAO,IAAI,MAAM,iBAAiB,CAAC,CAEvC,EACMI,EAAuB,IAAM,CAEjCF,EAAQ,EACRF,EAAO,IAAIK,CAAoB,CACjC,EACMH,EAAU,IAAM,CACpBvC,EAAA,KAAKnB,GAAa,oBAAoB,UAAWyD,CAAQ,EACzDtC,EAAA,KAAK3B,GAAa,oBAChB,gBACAoE,CACF,CACF,EACAzC,EAAA,KAAK3B,GAAa,iBAChB,gBACAoE,CACF,EACAzC,EAAA,KAAKnB,GAAa,iBAAiB,UAAWyD,CAAQ,CACxD,CACF,CACF,EA8KA/C,GAAoB,SAACgB,EAAiBoC,EAAiB,CACrD,IAAMC,EAAY5C,EAAA,KAAKjB,GAAiB,IAAIwB,CAAO,EACnD,GAAIqC,EACF,QAAWN,KAAYM,EACrB,eAAe,IAAMN,EAASK,CAAO,CAAC,EAG1C,QAAWL,KAAYtC,EAAA,KAAKhB,GAC1B,eAAe,IAAMsD,EAAS/B,EAASoC,CAAO,CAAC,CAEnD,EAzdK,IAAME,GAANrD,EAmhBP,eAAsBE,GAAO,CAAE,KAAAoD,CAAK,EAAkB,CAIpD,IAAMhC,EAAO,IAAO,OAAO,YAAgB,KAAe,YAAY,IAAM,YAAY,IAAI,EAAI,KAAK,IAAI,EACnGC,EAAKD,EAAK,EACVE,EAAQ,IAAM,KAAKF,EAAK,EAAIC,GAAI,QAAQ,CAAC,CAAC,KAEhD,QAAQ,KAAK,mCAAmCC,EAAM,CAAC,uCAAuC,EAG9F,QAAQ,MAAM,mCAAmCA,EAAM,CAAC,wCAAwC,EAChG,YAAY,CAAE,KAAM,MAAO,CAAC,EAG5B,QAAQ,MAAM,mCAAmCA,EAAM,CAAC,iDAAiD,EACzG,IAAM+B,EAAgBjC,EAAK,EACrBnB,EAAU,MAAM,IAAI,QACvBI,GAAY,CACX,iBACE,UACCE,GAAU,CACLA,EAAM,KAAK,OAAS,QACtBF,EAAQE,EAAM,KAAK,OAAO,CAE9B,EACA,CAAE,KAAM,EAAK,CACf,CACF,CACF,EACA,QAAQ,KAAK,mCAAmCe,EAAM,CAAC,qCAAqCF,EAAK,EAAIiC,GAAe,QAAQ,CAAC,CAAC,eAAepD,EAAQ,SAAW,WAAW,GAAG,EAM9K,IAAMqD,EAAKrD,EAAQ,IAAM,GAAG,YAAY,GAAG,IAAIA,EAAQ,SAAW,EAAE,GACpE,QAAQ,MAAM,mCAAmCqB,EAAM,CAAC,cAAcgC,CAAE,EAAE,EAG1E,QAAQ,MAAM,mCAAmChC,EAAM,CAAC,yCAAyC,EACjG,YAAY,CAAE,KAAM,QAAS,GAAAgC,CAAG,CAAC,EAEjC,IAAMC,EAAiB,wBAAwBD,CAAE,GAC3ClB,EAAqB,oBAAoBkB,CAAE,GAC3CE,EAAmB,IAAI,iBAAiBpB,CAAkB,EAC1DqB,EAAgB,IAAI,IAC1B,QAAQ,MAAM,mCAAmCnC,EAAM,CAAC,+BAA+Bc,CAAkB,EAAE,EAK3G,QAAQ,MAAM,mCAAmCd,EAAM,CAAC,6BAA6BiC,CAAc,KAAK,EACxG,IAAMG,EAAgBtC,EAAK,EAC3B,MAAMe,EAAYoB,CAAc,EAChC,QAAQ,KAAK,mCAAmCjC,EAAM,CAAC,gEAAgEF,EAAK,EAAIsC,GAAe,QAAQ,CAAC,CAAC,KAAK,EAG9J,QAAQ,MAAM,mCAAmCpC,EAAM,CAAC,qDAAqD,EAC7G,IAAMqC,EAAcvC,EAAK,EACnBwC,EAAYR,EAAKnD,CAAO,EAG9BuD,EAAiB,UAAY,MAAOjD,GAAU,CAC5C,IAAMsD,EAAMtD,EAAM,KAClB,OAAQsD,EAAI,KAAM,CAChB,IAAK,WAEH,QAAQ,MAAM,gEAAgEA,EAAI,EAAE,EAAE,EACtFC,GAAWD,EAAI,GAAI,MAAMD,EAAWH,CAAa,EACjD,KACJ,CACF,EAGA,QAAQ,MAAM,mCAAmCnC,EAAM,CAAC,6CAA6C,EACrGkC,EAAiB,YAAY,CAAE,KAAM,cAAe,GAAAF,CAAG,CAAC,EAGxD,QAAQ,MAAM,mCAAmChC,EAAM,CAAC,sCAAsC,EAC9F,YAAY,CAAE,KAAM,YAAa,CAAC,EAElC,QAAQ,MAAM,mCAAmCA,EAAM,CAAC,gDAAgD,EACxG,IAAMyC,EAAK,MAAMH,EACjB,QAAQ,KAAK,mCAAmCtC,EAAM,CAAC,sDAAsDF,EAAK,EAAIuC,GAAa,QAAQ,CAAC,CAAC,KAAK,EAGlJI,EAAG,eAAe,CAAClD,EAASoC,IAAY,CACtCO,EAAiB,YAAY,CAAE,KAAM,SAAU,QAAA3C,EAAS,QAAAoC,CAAQ,CAAC,CACnE,CAAC,EAED,IAAMV,GAAgBnB,EAAK,EAAIC,GAAI,QAAQ,CAAC,EAC5C,QAAQ,KAAK,mCAAmCC,EAAM,CAAC,wCAAwCiB,CAAY,gBAAgB,CAC7H,CAGA,IAAIyB,EAAkB,GAEtB,eAAeF,GAAWG,EAAevD,EAAY+C,EAA4B,CAC/E,IAAMrC,EAAO,IAAO,OAAO,YAAgB,KAAe,YAAY,IAAM,YAAY,IAAI,EAAI,KAAK,IAAI,EAEzG,GAAIqC,EAAc,IAAIQ,CAAK,EAAG,CAC5B,QAAQ,MAAM,mDAAmDA,CAAK,8BAA8B,EACpG,MACF,CAEA,QAAQ,MAAM,8DAA8DA,CAAK,EAAE,EACnFR,EAAc,IAAIQ,CAAK,EACvB,IAAM5B,EAAe,cAAc4B,CAAK,GAClChC,EAAiB,oBAAoBgC,CAAK,GAC1CC,EAAa,IAAI,iBAAiB7B,CAAY,EAGpD,UAAU,MAAM,QAAQJ,EAAgB,IAC/B,IAAI,QAAe5B,GAAY,CAEpC,QAAQ,MAAM,uCAAuC4D,CAAK,sBAAsB,EAChFC,EAAW,MAAM,EACjBT,EAAc,OAAOQ,CAAK,EAC1B5D,EAAQ,CACV,CAAC,CACF,EAED,IAAM8D,EAAMC,GAAcH,EAAOvD,CAAE,EAEnCwD,EAAW,iBAAiB,UAAW,MAAO3D,GAAU,CACtD,IAAMsD,EAAMtD,EAAM,KAClB,OAAQsD,EAAI,KAAM,CAChB,IAAK,WAAY,CACf,IAAMQ,EAAWjD,EAAK,EAChB,CAAE,OAAAsB,EAAQ,OAAAF,EAAQ,KAAAC,CAAK,EAAIoB,EAG5BG,GACH,QAAQ,KAAK,0DAA0DxB,CAAM,YAAYE,CAAM,EAAE,EAGnG,MAAMhC,EAAG,UAET,GAAI,CAEF,IAAM4D,EAAU,MAAMH,EAAI3B,CAAM,EAAE,GAAGC,CAAI,EAGzCyB,EAAW,YAAY,CACrB,KAAM,aACN,OAAAxB,EACA,OAAA4B,CACF,CAA0C,EAErCN,IACH,QAAQ,KAAK,mEAAmExB,CAAM,WAAWpB,EAAK,EAAIiD,GAAU,QAAQ,CAAC,CAAC,IAAI,EAClIL,EAAkB,GAEtB,OAASlB,EAAO,CACd,QAAQ,MAAMA,CAAK,EACnBoB,EAAW,YAAY,CACrB,KAAM,YACN,OAAAxB,EACA,MAAO,CAAE,QAAUI,EAAgB,OAAQ,CAC7C,CAA0B,CAC5B,CACA,KACF,CACF,CACF,CAAC,EAKD,IAAMyB,EAAmBnD,EAAK,EAC9B,GAAI,CAEF,MAAMV,EAAG,UAIT,MAAMA,EAAG,MAAM,0BAA0B,EAEzC,IAAM8D,GAAiBpD,EAAK,EAAImD,GAAkB,QAAQ,CAAC,EAC3D,QAAQ,MAAM,+DAA+DN,CAAK,KAAKO,CAAa,KAAK,EAGzG,QAAQ,MAAM,8DAA8DP,CAAK,EAAE,EACnFC,EAAW,YAAY,CAAE,KAAM,WAAY,CAAC,CAC9C,OAASO,EAAkB,CAEzB,QAAQ,MAAM,sEAAiER,CAAK,IAAKQ,CAAW,EACpG,QAAQ,MAAM,qEAAqEA,EAAY,OAAO,EAAE,EAGxGhB,EAAc,OAAOQ,CAAK,EAG1BC,EAAW,YAAY,CACrB,KAAM,mBACN,MAAO,CACL,QAAS,iCAAiCO,EAAY,OAAO,GAC7D,KAAM,qBACR,CACF,CAAC,EAGDP,EAAW,MAAM,CACnB,CACF,CAEA,SAASE,GAAcH,EAAeF,EAAY,CAChD,IAAIW,EAAwC,KACxCC,EAA8C,KAI5C1C,EAAiB,oBAAoBgC,CAAK,GAChD,OAAA9B,EAAYF,CAAc,EAAE,KAAK,IAAM,CACjC0C,GAEFZ,EAAG,KAAK,UAAU,EAEpBW,IAAmB,EACnBC,IAAyB,CAC3B,CAAC,EAEM,CACL,MAAM,eAAgB,CACpB,OAAOZ,EAAG,KACZ,EACA,MAAM,OAAQ,CACZ,MAAMA,EAAG,MAAM,CACjB,EACA,MAAM,aAAanD,EAAqB,CACtC,GAAM,CAAE,SAAAgE,EAAU,KAAAC,CAAK,EAAI,MAAMd,EAAG,aAAanD,CAAO,EACxD,GAAIiE,EAAK,aAAeA,EAAK,OAAO,WAAY,CAC9C,IAAMC,EAAS,IAAI,YAAYD,EAAK,UAAU,EACxCE,EAAW,IAAI,WAAWD,CAAM,EACtC,OAAAC,EAAS,IAAIF,CAAI,EACV,CAAE,SAAAD,EAAU,KAAMG,CAAS,CACpC,KACE,OAAO,CAAE,SAAAH,EAAU,KAAAC,CAAK,CAE5B,EACA,MAAM,mBAAmBjE,EAAqB,CAE5C,OADiB,MAAMmD,EAAG,mBAAmBnD,CAAO,CAEtD,EACA,MAAM,gBAAgBA,EAAqB,CACzC,IAAM0D,EAAS,MAAMP,EAAG,gBAAgBnD,CAAO,EAC/C,GAAI0D,EAAO,aAAeA,EAAO,OAAO,WAAY,CAGlD,IAAMQ,EAAS,IAAI,YAAYR,EAAO,UAAU,EAC1CU,EAAa,IAAI,WAAWF,CAAM,EACxC,OAAAE,EAAW,IAAIV,CAAM,EACdU,CACT,KACE,QAAOV,CAEX,EACA,MAAM,YAAYrD,EAAyC,CACzD,OAAO,MAAM8C,EAAG,YAAY9C,CAAW,CACzC,EACA,MAAM,UAAW,CACf,OAAO,MAAM8C,EAAG,SAAS,CAC3B,EACA,MAAM,YAAY7C,EAAoB,CACpC,OAAO,MAAM6C,EAAG,YAAY7C,CAAI,CAClC,EACA,MAAM,iBAAkB,CACtB,OAAO,MAAM6C,EAAG,gBAAgB,CAClC,EACA,MAAM,cAAe,CACnB,OAAO,MAAMA,EAAG,aAAa,CAC/B,EACA,MAAM,aAAc,CAClB,OAAO,MAAMA,EAAG,YAAY,CAC9B,EACA,MAAM,mBAAoB,CACxB,OAAO,IAAI,QAAe1D,GAAY,CACpC0D,EAAG,mBAAmB,IACb,IAAI,QAAekB,GAAY,CACpCP,EAAmBO,EACnB5E,EAAQ,CACV,CAAC,CACF,CACH,CAAC,CACH,EACA,MAAM,mBAAoB,CACxBqE,IAAmB,EACnBA,EAAmB,IACrB,EACA,MAAM,yBAA0B,CAC9B,OAAO,IAAI,QAAerE,GAAY,CACpC0D,EAAG,yBAAyB,IACnB,IAAI,QAAekB,GAAY,CACpCN,EAAyBM,EACzB5E,EAAQ,CACV,CAAC,CACF,CACH,CAAC,CACH,EACA,MAAM,yBAA0B,CAC9BsE,IAAyB,EACzBA,EAAyB,IAC3B,CACF,CACF,CAEO,IAAM3B,EAAN,cAAiC,KAAM,CAC5C,aAAc,CACZ,MAAM,0DAA0D,CAClE,CACF,EAEA,eAAeb,EAAY+C,EAAgB,CACzC,IAAID,EACJ,aAAM,IAAI,QAAe5E,GAAY,CACnC,UAAU,MAAM,QAAQ6E,EAAQ,IACvB,IAAI,QAAeC,GAAoB,CAC5CF,EAAUE,EACV9E,EAAQ,CACV,CAAC,CACF,CACH,CAAC,EACM4E,CACT","names":["init_esm_shims","_initPromise","_debug","_ready","_closed","_isLeader","_eventTarget","_tabId","_connected","_workerProcess","_workerID","_workerHerePromise","_workerReadyPromise","_broadcastChannel","_tabChannel","_releaseTabCloseLock","_notifyListeners","_globalNotifyListeners","_extensions","_extensionsClose","_PGliteWorker_instances","init_fn","leaderNotifyLoop_fn","rpc_fn","receiveNotification_fn","_PGliteWorker","BasePGlite","worker","options","__privateAdd","__privateSet","uuid","resolve","__privateGet","event","callback","__privateMethod","pg","_a","message","channel","tx","pgChannel","toPostgresName","compression","blob","fn","_now","t0","stamp","extensionCount","extSetupStart","extName","ext","extRet","instance","hereWaitStart","_","workerOptions","readyWaitStart","tabCloseLockId","tabLockStart","acquireLock","broadcastChannelId","tabChannelId","errorEvent","totalElapsed","method","args","callId","reject","listener","cleanup","error","leaderChangeListener","LeaderChangedError","payload","listeners","PGliteWorker","init","initWaitStart","id","electionLockId","broadcastChannel","connectedTabs","lockWaitStart","dbInitStart","dbPromise","msg","connectTab","db","firstRpcHandled","tabId","tabChannel","api","makeWorkerApi","rpcStart","result","healthCheckStart","healthCheckMs","healthError","queryLockRelease","transactionLockRelease","messages","data","buffer","dataCopy","resultCopy","release","lockId","releaseCallback"]}