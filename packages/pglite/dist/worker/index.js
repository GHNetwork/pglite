import{a as Y}from"../chunk-AX2J2225.js";import{u as j,x as Z}from"../chunk-YMWB5NPP.js";import"../chunk-MFIGESQR.js";import{e as r,f as l,g as u,h as m,j as X}from"../chunk-LXLR7NCL.js";X();var M,D,B,A,S,k,I,R,f,_,F,N,W,v,q,b,C,O,Q,c,te,H,y,re,V=class V extends Y{constructor(e,o){super();l(this,c);l(this,M);l(this,D,0);l(this,B,!1);l(this,A,!1);l(this,S,!1);l(this,k,new EventTarget);l(this,I);l(this,R,!1);l(this,f);l(this,_);l(this,F);l(this,N);l(this,W);l(this,v);l(this,q);l(this,b,new Map);l(this,C,new Set);l(this,O);l(this,Q,[]);u(this,f,e),u(this,I,j()),u(this,O,o?.extensions??{}),u(this,F,new Promise(i=>{r(this,f).addEventListener("message",t=>{if(t.data.type==="here")i();else throw new Error("Invalid message")},{once:!0})})),u(this,N,new Promise(i=>{let t=n=>{n.data.type==="ready"&&(u(this,_,n.data.id),r(this,f).removeEventListener("message",t),i())};r(this,f).addEventListener("message",t)})),u(this,M,m(this,c,te).call(this,o))}static async create(e,o){let i=new V(e,o);return await r(i,M),i}get waitReady(){return new Promise(e=>{r(this,M).then(()=>{r(this,R)?e():e(new Promise(o=>{r(this,k).addEventListener("connected",()=>{o()})}))})})}get debug(){return r(this,D)}get ready(){return r(this,B)}get closed(){return r(this,A)}get isLeader(){return r(this,S)}async close(){var e;r(this,A)||(u(this,A,!0),r(this,W)?.close(),r(this,v)?.close(),(e=r(this,q))==null||e.call(this),r(this,f).terminate())}async[Symbol.asyncDispose](){await this.close()}async execProtocolRaw(e){return await m(this,c,y).call(this,"execProtocolRaw",e)}async execProtocol(e){return await m(this,c,y).call(this,"execProtocol",e)}async execProtocolStream(e){return await m(this,c,y).call(this,"execProtocolStream",e)}async syncToFs(){await m(this,c,y).call(this,"syncToFs")}async listen(e,o,i){let t=Z(e),n=i??this;return r(this,b).has(t)||r(this,b).set(t,new Set),r(this,b).get(t).add(o),await n.exec(`LISTEN ${e}`),async h=>{await this.unlisten(t,o,h)}}async unlisten(e,o,i){await this.waitReady;let t=i??this;o?r(this,b).get(e)?.delete(o):r(this,b).delete(e),r(this,b).get(e)?.size===0&&await t.exec(`UNLISTEN ${e}`)}onNotification(e){return r(this,C).add(e),()=>{r(this,C).delete(e)}}offNotification(e){r(this,C).delete(e)}async dumpDataDir(e){return await m(this,c,y).call(this,"dumpDataDir",e)}onLeaderChange(e){return r(this,k).addEventListener("leader-change",e),()=>{r(this,k).removeEventListener("leader-change",e)}}offLeaderChange(e){r(this,k).removeEventListener("leader-change",e)}async _handleBlob(e){await m(this,c,y).call(this,"_handleBlob",e)}async _getWrittenBlob(){return await m(this,c,y).call(this,"_getWrittenBlob")}async _cleanupBlob(){await m(this,c,y).call(this,"_cleanupBlob")}async _checkReady(){await this.waitReady}async _runExclusiveQuery(e){await m(this,c,y).call(this,"_acquireQueryLock");try{return await e()}finally{await m(this,c,y).call(this,"_releaseQueryLock")}}async _runExclusiveTransaction(e){await m(this,c,y).call(this,"_acquireTransactionLock");try{return await e()}finally{await m(this,c,y).call(this,"_releaseTransactionLock")}}};M=new WeakMap,D=new WeakMap,B=new WeakMap,A=new WeakMap,S=new WeakMap,k=new WeakMap,I=new WeakMap,R=new WeakMap,f=new WeakMap,_=new WeakMap,F=new WeakMap,N=new WeakMap,W=new WeakMap,v=new WeakMap,q=new WeakMap,b=new WeakMap,C=new WeakMap,O=new WeakMap,Q=new WeakMap,c=new WeakSet,te=async function(e={}){let o=()=>typeof performance<"u"&&performance.now?performance.now():Date.now(),i=o(),t=()=>`+${(o()-i).toFixed(1)}ms`;console.info(`[PGliteInternal][worker-main] ${t()} ========== PGliteWorker #init START ==========`),console.debug(`[PGliteInternal][worker-main] ${t()} tabId=${r(this,I)}, dataDir=${e.dataDir??"memory://"}`);let n=Object.keys(r(this,O)).length;console.debug(`[PGliteInternal][worker-main] ${t()} setting up ${n} extension(s) on client side...`);let h=o();for(let[s,U]of Object.entries(r(this,O))){if(U instanceof URL)throw new Error("URL extensions are not supported on the client side of a worker");{let G=await U.setup(this,{},!0);if(G.emscriptenOpts&&console.warn(`PGlite extension ${s} returned emscriptenOpts, these are not supported on the client side of a worker`),G.namespaceObj){let oe=this;oe[s]=G.namespaceObj}G.bundlePath&&console.warn(`PGlite extension ${s} returned bundlePath, this is not supported on the client side of a worker`),G.init&&await G.init(),G.close&&r(this,Q).push(G.close)}}console.debug(`[PGliteInternal][worker-main] ${t()} extensions setup completed (took ${(o()-h).toFixed(1)}ms)`),console.debug(`[PGliteInternal][worker-main] ${t()} awaiting workerHerePromise (waiting for worker to post 'here')...`);let w=o();await r(this,F),console.info(`[PGliteInternal][worker-main] ${t()} workerHerePromise resolved (waited ${(o()-w).toFixed(1)}ms)`);let{extensions:p,...$}=e;console.debug(`[PGliteInternal][worker-main] ${t()} posting 'init' message to worker with options`),r(this,f).postMessage({type:"init",options:$}),console.debug(`[PGliteInternal][worker-main] ${t()} awaiting workerReadyPromise (waiting for worker to post 'ready')...`);let x=o();await r(this,N),console.info(`[PGliteInternal][worker-main] ${t()} workerReadyPromise resolved (waited ${(o()-x).toFixed(1)}ms, workerID=${r(this,_)})`);let g=`pglite-tab-close:${r(this,I)}`;console.debug(`[PGliteInternal][worker-main] ${t()} acquiring tab close lock: ${g}`);let P=o();u(this,q,await J(g)),console.debug(`[PGliteInternal][worker-main] ${t()} tab close lock acquired (took ${(o()-P).toFixed(1)}ms)`);let T=`pglite-broadcast:${r(this,_)}`;u(this,W,new BroadcastChannel(T)),console.debug(`[PGliteInternal][worker-main] ${t()} broadcast channel created: ${T}`);let E=`pglite-tab:${r(this,I)}`;u(this,v,new BroadcastChannel(E)),console.debug(`[PGliteInternal][worker-main] ${t()} tab channel created: ${E}`),r(this,W).addEventListener("message",async s=>{s.data.type==="leader-here"?(console.debug("[PGliteInternal][worker-main] received 'leader-here' on broadcast channel"),u(this,R,!1),r(this,k).dispatchEvent(new Event("leader-change")),m(this,c,H).call(this)):s.data.type==="notify"&&m(this,c,re).call(this,s.data.channel,s.data.payload)}),r(this,v).addEventListener("message",async s=>{if(s.data.type==="connected")console.info(`[PGliteInternal][worker-main] ${t()} received 'connected' on tab channel - connection established!`),u(this,R,!0),r(this,k).dispatchEvent(new Event("connected")),u(this,D,await m(this,c,y).call(this,"getDebugLevel")),u(this,B,!0),console.info(`[PGliteInternal][worker-main] ${t()} ready flag set, debug level=${r(this,D)}`);else if(s.data.type==="connection-error"){console.error(`[PGliteInternal][worker-main] ${t()} \u274C CONNECTION FAILED: ${s.data.error?.message}`),console.error("[PGliteInternal][worker-main] Database health check failed - database may be corrupted"),console.error("[PGliteInternal][worker-main] \u{1F4A1} Recovery: Clear site data and reload");let U=new CustomEvent("connection-error",{detail:{code:s.data.error?.code||"UNKNOWN",message:s.data.error?.message||"Connection failed"}});r(this,k).dispatchEvent(U),r(this,k).dispatchEvent(new ErrorEvent("error",{message:s.data.error?.message||"Database connection failed",error:new Error(s.data.error?.message||"Database connection failed")}))}}),r(this,f).addEventListener("message",async s=>{s.data.type==="leader-now"&&(console.info(`[PGliteInternal][worker-main] ${t()} received 'leader-now' - this tab is the leader`),u(this,S,!0),r(this,k).dispatchEvent(new Event("leader-change")))}),console.debug(`[PGliteInternal][worker-main] ${t()} starting leader notify loop`),m(this,c,H).call(this),console.debug(`[PGliteInternal][worker-main] ${t()} initiating _initArrayTypes() (not awaited)`),this._initArrayTypes();let L=(o()-i).toFixed(1);console.info(`[PGliteInternal][worker-main] ${t()} ========== PGliteWorker #init COMPLETE (total ${L}ms) ==========`)},H=async function(){r(this,R)||(r(this,W).postMessage({type:"tab-here",id:r(this,I)}),setTimeout(()=>m(this,c,H).call(this),16))},y=async function(e,...o){let i=j(),t={type:"rpc-call",callId:i,method:e,args:o};return r(this,v).postMessage(t),await new Promise((n,h)=>{let w=x=>{if(x.data.callId!==i)return;$();let g=x.data;if(g.type==="rpc-return")n(g.result);else if(g.type==="rpc-error"){let P=new Error(g.error.message);Object.assign(P,g.error),h(P)}else h(new Error("Invalid message"))},p=()=>{$(),h(new z)},$=()=>{r(this,v).removeEventListener("message",w),r(this,k).removeEventListener("leader-change",p)};r(this,k).addEventListener("leader-change",p),r(this,v).addEventListener("message",w)})},re=function(e,o){let i=r(this,b).get(e);if(i)for(let t of i)queueMicrotask(()=>t(o));for(let t of r(this,C))queueMicrotask(()=>t(e,o))};var ee=V;async function de({init:d}){let a=()=>typeof performance<"u"&&performance.now?performance.now():Date.now(),e=a(),o=()=>`+${(a()-e).toFixed(1)}ms`;console.info(`[PGliteInternal][worker-thread] ${o()} ========== worker() START ==========`),console.debug(`[PGliteInternal][worker-thread] ${o()} posting 'here' message to main thread`),postMessage({type:"here"}),console.debug(`[PGliteInternal][worker-thread] ${o()} waiting for 'init' message from main thread...`);let i=a(),t=await new Promise(L=>{addEventListener("message",s=>{s.data.type==="init"&&L(s.data.options)},{once:!0})});console.info(`[PGliteInternal][worker-thread] ${o()} received 'init' message (waited ${(a()-i).toFixed(1)}ms, dataDir=${t.dataDir??"memory://"})`);let n=t.id??`${import.meta.url}:${t.dataDir??""}`;console.debug(`[PGliteInternal][worker-thread] ${o()} worker id=${n}`),console.debug(`[PGliteInternal][worker-thread] ${o()} posting 'ready' message to main thread`),postMessage({type:"ready",id:n});let h=`pglite-election-lock:${n}`,w=`pglite-broadcast:${n}`,p=new BroadcastChannel(w),$=new Set;console.debug(`[PGliteInternal][worker-thread] ${o()} broadcast channel created: ${w}`),console.debug(`[PGliteInternal][worker-thread] ${o()} acquiring election lock: ${h}...`);let x=a();await J(h),console.info(`[PGliteInternal][worker-thread] ${o()} election lock acquired - THIS WORKER IS NOW LEADER (waited ${(a()-x).toFixed(1)}ms)`),console.debug(`[PGliteInternal][worker-thread] ${o()} calling init(options) to create PGlite instance...`);let g=a(),P=d(t);p.onmessage=async L=>{let s=L.data;switch(s.type){case"tab-here":console.debug(`[PGliteInternal][worker-thread] received 'tab-here' from tab ${s.id}`),ne(s.id,await P,$);break}},console.debug(`[PGliteInternal][worker-thread] ${o()} posting 'leader-here' to broadcast channel`),p.postMessage({type:"leader-here",id:n}),console.debug(`[PGliteInternal][worker-thread] ${o()} posting 'leader-now' to main thread`),postMessage({type:"leader-now"}),console.debug(`[PGliteInternal][worker-thread] ${o()} awaiting dbPromise (PGlite initialization)...`);let T=await P;console.info(`[PGliteInternal][worker-thread] ${o()} dbPromise resolved - PGlite instance ready (took ${(a()-g).toFixed(1)}ms)`),T.onNotification((L,s)=>{p.postMessage({type:"notify",channel:L,payload:s})});let E=(a()-e).toFixed(1);console.info(`[PGliteInternal][worker-thread] ${o()} ========== worker() COMPLETE (total ${E}ms) ==========`)}var K=!1;async function ne(d,a,e){let o=()=>typeof performance<"u"&&performance.now?performance.now():Date.now();if(e.has(d)){console.debug(`[PGliteInternal][worker-thread] connectTab: tab ${d} already connected, skipping`);return}console.debug(`[PGliteInternal][worker-thread] connectTab: connecting tab ${d}`),e.add(d);let i=`pglite-tab:${d}`,t=`pglite-tab-close:${d}`,n=new BroadcastChannel(i);navigator.locks.request(t,()=>new Promise(p=>{console.debug(`[PGliteInternal][worker-thread] tab ${d} closed, cleaning up`),n.close(),e.delete(d),p()}));let h=ae(d,a);n.addEventListener("message",async p=>{let $=p.data;switch($.type){case"rpc-call":{let x=o(),{callId:g,method:P,args:T}=$;K||console.info(`[PGliteInternal][worker-thread] FIRST RPC CALL: method=${P}, callId=${g}`),await a.waitReady;try{let E=await h[P](...T);n.postMessage({type:"rpc-return",callId:g,result:E}),K||(console.info(`[PGliteInternal][worker-thread] FIRST RPC CALL COMPLETE: method=${P}, took ${(o()-x).toFixed(1)}ms`),K=!0)}catch(E){console.error(E),n.postMessage({type:"rpc-error",callId:g,error:{message:E.message}})}break}}});let w=o();try{await a.waitReady,await a.query("SELECT 1 as health_check");let p=(o()-w).toFixed(1);console.debug(`[PGliteInternal][worker-thread] health check passed for tab ${d} (${p}ms)`),console.debug(`[PGliteInternal][worker-thread] posting 'connected' to tab ${d}`),n.postMessage({type:"connected"})}catch(p){console.error(`[PGliteInternal][worker-thread] \u274C Health check FAILED for tab ${d}:`,p),console.error(`[PGliteInternal][worker-thread] Database may be corrupted. Error: ${p.message}`),e.delete(d),n.postMessage({type:"connection-error",error:{message:`Database health check failed: ${p.message}`,code:"HEALTH_CHECK_FAILED"}}),n.close()}}function ae(d,a){let e=null,o=null,i=`pglite-tab-close:${d}`;return J(i).then(()=>{o&&a.exec("ROLLBACK"),e?.(),o?.()}),{async getDebugLevel(){return a.debug},async close(){await a.close()},async execProtocol(t){let{messages:n,data:h}=await a.execProtocol(t);if(h.byteLength!==h.buffer.byteLength){let w=new ArrayBuffer(h.byteLength),p=new Uint8Array(w);return p.set(h),{messages:n,data:p}}else return{messages:n,data:h}},async execProtocolStream(t){return await a.execProtocolStream(t)},async execProtocolRaw(t){let n=await a.execProtocolRaw(t);if(n.byteLength!==n.buffer.byteLength){let h=new ArrayBuffer(n.byteLength),w=new Uint8Array(h);return w.set(n),w}else return n},async dumpDataDir(t){return await a.dumpDataDir(t)},async syncToFs(){return await a.syncToFs()},async _handleBlob(t){return await a._handleBlob(t)},async _getWrittenBlob(){return await a._getWrittenBlob()},async _cleanupBlob(){return await a._cleanupBlob()},async _checkReady(){return await a._checkReady()},async _acquireQueryLock(){return new Promise(t=>{a._runExclusiveQuery(()=>new Promise(n=>{e=n,t()}))})},async _releaseQueryLock(){e?.(),e=null},async _acquireTransactionLock(){return new Promise(t=>{a._runExclusiveTransaction(()=>new Promise(n=>{o=n,t()}))})},async _releaseTransactionLock(){o?.(),o=null}}}var z=class extends Error{constructor(){super("Leader changed, pending operation in indeterminate state")}};async function J(d){let a;return await new Promise(e=>{navigator.locks.request(d,()=>new Promise(o=>{a=o,e()}))}),a}export{z as LeaderChangedError,ee as PGliteWorker,de as worker};
//# sourceMappingURL=index.js.map