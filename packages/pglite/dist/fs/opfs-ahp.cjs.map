{"version":3,"sources":["../../../../../../node_modules/.pnpm/tsup@8.5.1_@microsoft+api-extractor@7.55.2_@types+node@24.10.0__jiti@2.6.1_postcss@8.5._bfbfcd9e3cea35d6b2e86cddb83bddc6/node_modules/tsup/assets/cjs_shims.js","../../../../../../node_modules/.pnpm/tinytar@0.1.0/node_modules/tinytar/lib/utils.js","../../../../../../node_modules/.pnpm/tinytar@0.1.0/node_modules/tinytar/lib/constants.js","../../../../../../node_modules/.pnpm/tinytar@0.1.0/node_modules/tinytar/lib/types.js","../../../../../../node_modules/.pnpm/tinytar@0.1.0/node_modules/tinytar/lib/tar.js","../../../../../../node_modules/.pnpm/tinytar@0.1.0/node_modules/tinytar/lib/untar.js","../../../../../../node_modules/.pnpm/tinytar@0.1.0/node_modules/tinytar/index.js","../../src/fs/opfs-ahp.ts","../../src/fs/base.ts","../../src/fs/tarUtils.ts"],"sourcesContent":["// Shim globals in cjs bundle\n// There's a weird bug that esbuild will always inject importMetaUrl\n// if we export it as `const importMetaUrl = ... __filename ...`\n// But using a function will not cause this issue\n\nconst getImportMetaUrl = () => \n  typeof document === \"undefined\" \n    ? new URL(`file:${__filename}`).href \n    : (document.currentScript && document.currentScript.tagName.toUpperCase() === 'SCRIPT') \n      ? document.currentScript.src \n      : new URL(\"main.js\", document.baseURI).href;\n\nexport const importMetaUrl = /* @__PURE__ */ getImportMetaUrl()\n","'use strict';\n\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\nvar undefined = (function(undefined) {\n  return undefined;\n})();\n\nfunction isUndefined(value) {\n  return value === undefined;\n}\n\nfunction isString(value) {\n  return (typeof value == 'string') ||\n    (Object.prototype.toString.call(value) == '[object String]');\n}\n\nfunction isDateTime(value) {\n  return (Object.prototype.toString.call(value) == '[object Date]');\n}\n\nfunction isObject(value) {\n  return (value !== null) && (typeof value == 'object');\n}\n\nfunction isFunction(value) {\n  return typeof value == 'function';\n}\n\nfunction isLength(value) {\n  return (typeof value == 'number') &&\n    (value > -1) && (value % 1 == 0) &&\n    (value <= MAX_SAFE_INTEGER);\n}\n\nfunction isArray(value) {\n  return Object.prototype.toString.call(value) == '[object Array]';\n}\n\nfunction isArrayLike(value) {\n  return isObject(value) && !isFunction(value) && isLength(value.length);\n}\n\nfunction isArrayBuffer(value) {\n  return Object.prototype.toString.call(value) == '[object ArrayBuffer]';\n}\n\nfunction map(array, iteratee) {\n  return Array.prototype.map.call(array, iteratee);\n}\n\nfunction find(array, iteratee) {\n  var result = undefined;\n\n  if (isFunction(iteratee)) {\n    Array.prototype.every.call(array, function(item, index, array) {\n      var found = iteratee(item, index, array);\n      if (found) {\n        result = item;\n      }\n      return !found;  // continue if not found\n    });\n  }\n\n  return result;\n}\n\nfunction extend(target /* ...sources */) {\n  return Object.assign.apply(null, arguments);\n}\n\nfunction toUint8Array(value) {\n  var i;\n  var length;\n  var result;\n\n  if (isString(value)) {\n    length = value.length;\n    result = new Uint8Array(length);\n    for (i = 0; i < length; i++) {\n      result[i] = value.charCodeAt(i) & 0xFF;\n    }\n    return result;\n  }\n\n  if (isArrayBuffer(value)) {\n    return new Uint8Array(value);\n  }\n\n  if (isObject(value) && isArrayBuffer(value.buffer)) {\n    return new Uint8Array(value.buffer);\n  }\n\n  if (isArrayLike(value)) {\n    return new Uint8Array(value);\n  }\n\n  if (isObject(value) && isFunction(value.toString)) {\n    return toUint8Array(value.toString());\n  }\n\n  return new Uint8Array();\n}\n\nmodule.exports.MAX_SAFE_INTEGER = MAX_SAFE_INTEGER;\n\nmodule.exports.isUndefined = isUndefined;\nmodule.exports.isString = isString;\nmodule.exports.isObject = isObject;\nmodule.exports.isDateTime = isDateTime;\nmodule.exports.isFunction = isFunction;\nmodule.exports.isArray = isArray;\nmodule.exports.isArrayLike = isArrayLike;\nmodule.exports.isArrayBuffer = isArrayBuffer;\nmodule.exports.map = map;\nmodule.exports.find = find;\nmodule.exports.extend = extend;\nmodule.exports.toUint8Array = toUint8Array;\n","'use strict';\n\nvar NULL_CHAR = '\\u0000';\n\nmodule.exports = {\n  /* eslint-disable key-spacing */\n\n  NULL_CHAR: NULL_CHAR,\n\n  TMAGIC: 'ustar' + NULL_CHAR + '00',   // 'ustar', NULL, '00'\n  OLDGNU_MAGIC: 'ustar  ' + NULL_CHAR,  // 'ustar  ', NULL\n\n  // Values used in typeflag field.\n  REGTYPE:  0,  // regular file\n  LNKTYPE:  1,  // link\n  SYMTYPE:  2,  // reserved\n  CHRTYPE:  3,  // character special\n  BLKTYPE:  4,  // block special\n  DIRTYPE:  5,  // directory\n  FIFOTYPE: 6,  // FIFO special\n  CONTTYPE: 7,  // reserved\n\n  // Bits used in the mode field, values in octal.\n  TSUID: parseInt('4000', 8),  // set UID on execution\n  TSGID: parseInt('2000', 8),  // set GID on execution\n  TSVTX: parseInt('1000', 8),  // reserved\n\n  // file permissions\n  TUREAD:  parseInt('0400', 8),  // read by owner\n  TUWRITE: parseInt('0200', 8),  // write by owner\n  TUEXEC:  parseInt('0100', 8),  // execute/search by owner\n  TGREAD:  parseInt('0040', 8),  // read by group\n  TGWRITE: parseInt('0020', 8),  // write by group\n  TGEXEC:  parseInt('0010', 8),  // execute/search by group\n  TOREAD:  parseInt('0004', 8),  // read by other\n  TOWRITE: parseInt('0002', 8),  // write by other\n  TOEXEC:  parseInt('0001', 8),   // execute/search by other\n\n  TPERMALL:  parseInt('0777', 8),   // rwxrwxrwx\n  TPERMMASK: parseInt('0777', 8)    // permissions bitmask\n\n  /* eslint-enable key-spacing */\n};\n","'use strict';\n\nvar utils = require('./utils');\nvar constants = require('./constants');\n\nvar recordSize = 512;\nvar defaultFileMode = constants.TPERMALL;  // rwxrwxrwx\nvar defaultUid = 0;  // root\nvar defaultGid = 0;  // root\n\n/*\n struct posix_header {           // byte offset\n char name[100];               //   0\n char mode[8];                 // 100\n char uid[8];                  // 108\n char gid[8];                  // 116\n char size[12];                // 124\n char mtime[12];               // 136\n char chksum[8];               // 148\n char typeflag;                // 156\n char linkname[100];           // 157\n char magic[6];                // 257\n char version[2];              // 263\n char uname[32];               // 265\n char gname[32];               // 297\n char devmajor[8];             // 329\n char devminor[8];             // 337\n char prefix[131];             // 345\n char atime[12];               // 476\n char ctime[12];               // 488\n };\n */\n\nvar posixHeader = [\n  // <field name>, <size>, <offset>, <used>, <format>, <parse>, [ <check> ]\n  ['name', 100, 0, function(file, field) {\n    return formatTarString(file[field[0]], field[1]);\n  }, function(buffer, offset, field) {\n    return parseTarString(buffer.slice(offset, offset + field[1]));\n  }],\n  ['mode', 8, 100, function(file, field) {\n    var mode = file[field[0]] || defaultFileMode;\n    mode = mode & constants.TPERMMASK;\n    return formatTarNumber(mode, field[1], defaultFileMode);\n  }, function(buffer, offset, field) {\n    var result = parseTarNumber(buffer.slice(offset, offset + field[1]));\n    result &= constants.TPERMMASK;\n    return result;\n  }],\n  ['uid', 8, 108, function(file, field) {\n    return formatTarNumber(file[field[0]], field[1], defaultUid);\n  }, function(buffer, offset, field) {\n    return parseTarNumber(buffer.slice(offset, offset + field[1]));\n  }],\n  ['gid', 8, 116, function(file, field) {\n    return formatTarNumber(file[field[0]], field[1], defaultGid);\n  }, function(buffer, offset, field) {\n    return parseTarNumber(buffer.slice(offset, offset + field[1]));\n  }],\n  ['size', 12, 124, function(file, field) {\n    return formatTarNumber(file.data.length, field[1]);\n  }, function(buffer, offset, field) {\n    return parseTarNumber(buffer.slice(offset, offset + field[1]));\n  }],\n  ['modifyTime', 12, 136, function(file, field) {\n    return formatTarDateTime(file[field[0]], field[1]);\n  }, function(buffer, offset, field) {\n    return parseTarDateTime(buffer.slice(offset, offset + field[1]));\n  }],\n  ['checksum', 8, 148, function(file, field) {\n    return '        ';  // placeholder\n  }, function(buffer, offset, field) {\n    return parseTarNumber(buffer.slice(offset, offset + field[1]));\n  }],\n  ['type', 1, 156, function(file, field) {\n    // get last octal digit; 0 - regular file\n    return '' + ((parseInt(file[field[0]], 10) || 0) % 8);\n  }, function(buffer, offset, field) {\n    return (parseInt(String.fromCharCode(buffer[offset]), 10) || 0) % 8;\n  }],\n  ['linkName', 100, 157, function(file, field) {\n    return '';  // only regular files are supported\n  }, function(buffer, offset, field) {\n    return parseTarString(buffer.slice(offset, offset + field[1]));\n  }],\n  ['ustar', 8, 257, function(file, field) {\n    return constants.TMAGIC;  // magic + version\n  }, function(buffer, offset, field) {\n    return fixUstarMagic(\n      parseTarString(buffer.slice(offset, offset + field[1]), true)\n    );\n  }, function(file, field) {\n    return (file[field[0]] == constants.TMAGIC) ||\n      (file[field[0]] == constants.OLDGNU_MAGIC);\n  }],\n  ['owner', 32, 265, function(file, field) {\n    return formatTarString(file[field[0]], field[1]);\n  }, function(buffer, offset, field) {\n    return parseTarString(buffer.slice(offset, offset + field[1]));\n  }],\n  ['group', 32, 297, function(file, field) {\n    return formatTarString(file[field[0]], field[1]);\n  }, function(buffer, offset, field) {\n    return parseTarString(buffer.slice(offset, offset + field[1]));\n  }],\n  ['majorNumber', 8, 329, function(file, field) {\n    return '';  // only regular files are supported\n  }, function(buffer, offset, field) {\n    return parseTarNumber(buffer.slice(offset, offset + field[1]));\n  }],\n  ['minorNumber', 8, 337, function(file, field) {\n    return '';  // only regular files are supported\n  }, function(buffer, offset, field) {\n    return parseTarNumber(buffer.slice(offset, offset + field[1]));\n  }],\n  ['prefix', 131, 345, function(file, field) {\n    return formatTarString(file[field[0]], field[1]);\n  }, function(buffer, offset, field) {\n    return parseTarString(buffer.slice(offset, offset + field[1]));\n  }],\n  ['accessTime', 12, 476, function(file, field) {\n    return formatTarDateTime(file[field[0]], field[1]);\n  }, function(buffer, offset, field) {\n    return parseTarDateTime(buffer.slice(offset, offset + field[1]));\n  }],\n  ['createTime', 12, 488, function(file, field) {\n    return formatTarDateTime(file[field[0]], field[1]);\n  }, function(buffer, offset, field) {\n    return parseTarDateTime(buffer.slice(offset, offset + field[1]));\n  }]\n];\n\nvar effectiveHeaderSize = (function(header) {\n  var last = header[header.length - 1];\n  return last[2] + last[1];  // offset + size\n})(posixHeader);\n\nfunction fixUstarMagic(value) {\n  if (value.length == 8) {\n    var chars = value.split('');\n\n    if (chars[5] == constants.NULL_CHAR) {\n      // TMAGIC ?\n      if ((chars[6] == ' ') || (chars[6] == constants.NULL_CHAR)) {\n        chars[6] = '0';\n      }\n      if ((chars[7] == ' ') || (chars[7] == constants.NULL_CHAR)) {\n        chars[7] = '0';\n      }\n      chars = chars.join('');\n      return chars == constants.TMAGIC ? chars : value;\n    } else if (chars[7] == constants.NULL_CHAR) {\n      // OLDGNU_MAGIC ?\n      if (chars[5] == constants.NULL_CHAR) {\n        chars[5] = ' ';\n      }\n      if (chars[6] == constants.NULL_CHAR) {\n        chars[6] = ' ';\n      }\n      return chars == constants.OLDGNU_MAGIC ? chars : value;\n    }\n  }\n  return value;\n}\n\nfunction formatTarString(value, length) {\n  length -= 1;  // preserve space for trailing null-char\n  if (utils.isUndefined(value)) {\n    value = '';\n  }\n  value = ('' + value).substr(0, length);\n  return value + constants.NULL_CHAR;\n}\n\nfunction formatTarNumber(value, length, defaultValue) {\n  defaultValue = parseInt(defaultValue) || 0;\n  length -= 1;  // preserve space for trailing null-char\n  value = (parseInt(value) || defaultValue)\n    .toString(8).substr(-length, length);\n  while (value.length < length) {\n    value = '0' + value;\n  }\n  return value + constants.NULL_CHAR;\n}\n\nfunction formatTarDateTime(value, length) {\n  if (utils.isDateTime(value)) {\n    value = Math.floor(1 * value / 1000);\n  } else {\n    value = parseInt(value, 10);\n    if (isFinite(value)) {\n      if (value <= 0) {\n        return '';\n      }\n    } else {\n      value = Math.floor(1 * new Date() / 1000);\n    }\n  }\n  return formatTarNumber(value, length, 0);\n}\n\nfunction parseTarString(bytes, returnUnprocessed) {\n  var result = String.fromCharCode.apply(null, bytes);\n  if (returnUnprocessed) {\n    return result;\n  }\n  var index = result.indexOf(constants.NULL_CHAR);\n  return index >= 0 ? result.substr(0, index) : result;\n}\n\nfunction parseTarNumber(bytes) {\n  var result = String.fromCharCode.apply(null, bytes);\n  return parseInt(result.replace(/^0+$/g, ''), 8) || 0;\n}\n\nfunction parseTarDateTime(bytes) {\n  if ((bytes.length == 0) || (bytes[0] == 0)) {\n    return null;\n  }\n  return new Date(1000 * parseTarNumber(bytes));\n}\n\nfunction calculateChecksum(buffer, offset, skipChecksum) {\n  var from = parseInt(offset, 10) || 0;\n  var to = Math.min(from + effectiveHeaderSize, buffer.length);\n  var result = 0;\n\n  // When calculating checksum, `checksum` field should be\n  // threat as filled with space char (byte 32)\n  var skipFrom = 0;\n  var skipTo = 0;\n  if (skipChecksum) {\n    posixHeader.every(function(field) {\n      if (field[0] == 'checksum') {\n        skipFrom = from + field[2];\n        skipTo = skipFrom + field[1];\n        return false;\n      }\n      return true;\n    });\n  }\n\n  var whitespace = ' '.charCodeAt(0);\n  for (var i = from; i < to; i++) {\n    // 262144 = 8^6 - 6 octal digits - maximum possible value for checksum;\n    // wrap to avoid numeric overflow\n    var byte = (i >= skipFrom) && (i < skipTo) ? whitespace : buffer[i];\n    result = (result + byte) % 262144;\n  }\n  return result;\n}\n\nmodule.exports.recordSize = recordSize;\nmodule.exports.defaultFileMode = defaultFileMode;\nmodule.exports.defaultUid = defaultUid;\nmodule.exports.defaultGid = defaultGid;\nmodule.exports.posixHeader = posixHeader;\nmodule.exports.effectiveHeaderSize = effectiveHeaderSize;\n\nmodule.exports.calculateChecksum = calculateChecksum;\nmodule.exports.formatTarString = formatTarString;\nmodule.exports.formatTarNumber = formatTarNumber;\nmodule.exports.formatTarDateTime = formatTarDateTime;\nmodule.exports.parseTarString = parseTarString;\nmodule.exports.parseTarNumber = parseTarNumber;\nmodule.exports.parseTarDateTime = parseTarDateTime;\n\n","'use strict';\n\nvar constants = require('./constants');\nvar utils = require('./utils');\nvar types = require('./types');\n\nfunction headerSize(file) {\n  // header has fixed size\n  return types.recordSize;\n}\n\nfunction dataSize(file) {\n  // align to record boundary\n  return Math.ceil(file.data.length / types.recordSize) * types.recordSize;\n}\n\nfunction allocateBuffer(files) {\n  var totalSize = 0;\n\n  // Calculate space that will be used by each file\n  files.forEach(function(file) {\n    totalSize += headerSize(file) + dataSize(file);\n  });\n\n  // TAR must end with two empty records\n  totalSize += types.recordSize * 2;\n\n  // Array SHOULD be initialized with zeros:\n  // from TypedArray constructor docs:\n  // > When creating a TypedArray instance (i.e. instance of Int8Array\n  // > or similar), an array buffer is created internally\n  // from ArrayBuffer constructor docs:\n  // > A new ArrayBuffer object of the specified size.\n  // > Its contents are initialized to 0.\n  return new Uint8Array(totalSize);\n}\n\nfunction writeHeader(buffer, file, offset) {\n  offset = parseInt(offset) || 0;\n\n  var currentOffset = offset;\n  types.posixHeader.forEach(function(field) {\n    var value = field[3](file, field);\n    var length = value.length;\n    for (var i = 0; i < length; i += 1) {\n      buffer[currentOffset + i] = value.charCodeAt(i) & 0xFF;\n    }\n    currentOffset += field[1];  // move to the next field\n  });\n\n  var field = utils.find(types.posixHeader, function(field) {\n    return field[0] == 'checksum';\n  });\n\n  if (field) {\n    // Patch checksum field\n    var checksum = types.calculateChecksum(buffer, offset, true);\n    var value = types.formatTarNumber(checksum, field[1] - 2) +\n      constants.NULL_CHAR + ' ';\n    currentOffset = offset + field[2];\n    for (var i = 0; i < value.length; i += 1) {\n      // put bytes\n      buffer[currentOffset] = value.charCodeAt(i) & 0xFF;\n      currentOffset++;\n    }\n  }\n\n  return offset + headerSize(file);\n}\n\nfunction writeData(buffer, file, offset) {\n  offset = parseInt(offset, 10) || 0;\n  buffer.set(file.data, offset);\n  return offset + dataSize(file);\n}\n\nfunction tar(files) {\n  files = utils.map(files, function(file) {\n    return utils.extend({}, file, {\n      data: utils.toUint8Array(file.data)\n    });\n  });\n\n  var buffer = allocateBuffer(files);\n\n  var offset = 0;\n  files.forEach(function(file) {\n    offset = writeHeader(buffer, file, offset);\n    offset = writeData(buffer, file, offset);\n  });\n\n  return buffer;\n}\n\nmodule.exports.tar = tar;\n","'use strict';\n\nvar constants = require('./constants');\nvar utils = require('./utils');\nvar types = require('./types');\n\nvar defaultOptions = {\n  extractData: true,\n  checkHeader: true,\n  checkChecksum: true,\n  checkFileSize: true\n};\n\nvar excludeFields = {\n  size: true,\n  checksum: true,\n  ustar: true\n};\n\nvar messages = {\n  unexpectedEndOfFile: 'Unexpected end of file.',\n  fileCorrupted: 'File is corrupted.',\n  checksumCheckFailed: 'Checksum check failed.'\n};\n\nfunction headerSize(header) {\n  // header has fixed size\n  return types.recordSize;\n}\n\nfunction dataSize(size) {\n  // align to record boundary\n  return Math.ceil(size / types.recordSize) * types.recordSize;\n}\n\nfunction isEndOfFile(buffer, offset) {\n  var from = offset;\n  var to = Math.min(buffer.length, offset + types.recordSize * 2);\n  for (var i = from; i < to; i++) {\n    if (buffer[i] != 0) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction readHeader(buffer, offset, options) {\n  if (buffer.length - offset < types.recordSize) {\n    if (options.checkFileSize) {\n      throw new Error(messages.unexpectedEndOfFile);\n    }\n    return null;\n  }\n\n  offset = parseInt(offset) || 0;\n\n  var result = {};\n  var currentOffset = offset;\n  types.posixHeader.forEach(function(field) {\n    result[field[0]] = field[4](buffer, currentOffset, field);\n    currentOffset += field[1];\n  });\n\n  if (result.type != 0) {  // only regular files can have data\n    result.size = 0;\n  }\n\n  if (options.checkHeader) {\n    types.posixHeader.forEach(function(field) {\n      if (utils.isFunction(field[5]) && !field[5](result, field)) {\n        var error = new Error(messages.fileCorrupted);\n        error.data = {\n          offset: offset + field[2],\n          field: field[0]\n        };\n        throw error;\n      }\n    });\n  }\n\n  if (options.checkChecksum) {\n    var checksum = types.calculateChecksum(buffer, offset, true);\n    if (checksum != result.checksum) {\n      var error = new Error(messages.checksumCheckFailed);\n      error.data = {\n        offset: offset,\n        header: result,\n        checksum: checksum\n      };\n      throw error;\n    }\n  }\n\n  return result;\n}\n\nfunction readData(buffer, offset, header, options) {\n  if (!options.extractData) {\n    return null;\n  }\n\n  if (header.size <= 0) {\n    return new Uint8Array();\n  }\n  return buffer.slice(offset, offset + header.size);\n}\n\nfunction createFile(header, data) {\n  var result = {};\n  types.posixHeader.forEach(function(field) {\n    var name = field[0];\n    if (!excludeFields[name]) {\n      result[name] = header[name];\n    }\n  });\n\n  result.isOldGNUFormat = header.ustar == constants.OLDGNU_MAGIC;\n\n  if (data) {\n    result.data = data;\n  }\n\n  return result;\n}\n\nfunction untar(buffer, options) {\n  options = utils.extend({}, defaultOptions, options);\n\n  var result = [];\n  var offset = 0;\n  var size = buffer.length;\n\n  while (size - offset >= types.recordSize) {\n    buffer = utils.toUint8Array(buffer);\n    var header = readHeader(buffer, offset, options);\n    if (!header) {\n      break;\n    }\n    offset += headerSize(header);\n\n    var data = readData(buffer, offset, header, options);\n    result.push(createFile(header, data));\n    offset += dataSize(header.size);\n\n    if (isEndOfFile(buffer, offset)) {\n      break;\n    }\n  }\n\n  return result;\n}\n\nmodule.exports.untar = untar;\n","'use strict';\n\n// http://www.gnu.org/software/tar/manual/html_node/Standard.html\n\nvar utils = require('./lib/utils');\nvar constants = require('./lib/constants');\nvar tar = require('./lib/tar');\nvar untar = require('./lib/untar');\n\nutils.extend(module.exports, tar, untar, constants);\n","import { BaseFilesystem, ERRNO_CODES, type FsStats } from './base.js'\nimport type { PostgresMod } from '../postgresMod.js'\nimport { PGlite } from '../pglite.js'\n\nexport interface OpfsAhpOptions {\n  initialPoolSize?: number\n  maintainedPoolSize?: number\n  debug?: boolean\n}\n\n// TypeScript doesn't have a built-in type for FileSystemSyncAccessHandle\nexport interface FileSystemSyncAccessHandle {\n  close(): void\n  flush(): void\n  getSize(): number\n  read(buffer: BufferSource, options: { at: number }): number\n  truncate(newSize: number): void\n  write(buffer: BufferSource, options: { at: number }): number\n}\n\n// State\n\nconst STATE_FILE = 'state.txt'\nconst DATA_DIR = 'data'\nconst INITIAL_MODE = {\n  DIR: 16384,\n  FILE: 32768,\n}\n\nexport interface State {\n  root: DirectoryNode\n  pool: PoolFilenames\n}\n\nexport type PoolFilenames = Array<string>\n\n// WAL\n\nexport interface WALEntry {\n  opp: string\n  args: any[]\n}\n\n// Node tree\n\nexport type NodeType = 'file' | 'directory'\n\ninterface BaseNode {\n  type: NodeType\n  lastModified: number\n  mode: number\n}\n\nexport interface FileNode extends BaseNode {\n  type: 'file'\n  backingFilename: string\n}\n\nexport interface DirectoryNode extends BaseNode {\n  type: 'directory'\n  children: { [filename: string]: Node }\n}\n\nexport type Node = FileNode | DirectoryNode\n\n/**\n * PGlite OPFS access handle pool filesystem.\n * Opens a pool of sync access handles and then allocates them as needed.\n */\nexport class OpfsAhpFS extends BaseFilesystem {\n  declare readonly dataDir: string\n  readonly initialPoolSize: number\n  readonly maintainedPoolSize: number\n\n  #opfsRootAh!: FileSystemDirectoryHandle\n  #rootAh!: FileSystemDirectoryHandle\n  #dataDirAh!: FileSystemDirectoryHandle\n\n  #stateFH!: FileSystemFileHandle\n  #stateSH!: FileSystemSyncAccessHandle\n\n  #fh: Map<string, FileSystemFileHandle> = new Map()\n  #sh: Map<string, FileSystemSyncAccessHandle> = new Map()\n\n  #handleIdCounter = 0\n  #openHandlePaths: Map<number, string> = new Map()\n  #openHandleIds: Map<string, number> = new Map()\n\n  state!: State\n  lastCheckpoint = 0\n  // [NMT CUSTOMIZATION] Reduced from 60 seconds to 5 seconds to minimize data loss window\n  // RATIONALE: With the original 60-second interval, data changes could be lost if the user\n  // closed the tab, reloaded the page, or the browser crashed before the checkpoint.\n  // A 5-second interval provides much better durability while maintaining acceptable performance.\n  // Combined with relaxedDurability: false, this ensures near-immediate data persistence.\n  checkpointInterval = 1000 * 5 // 5 seconds (was 60 seconds)\n  poolCounter = 0\n\n  #unsyncedSH = new Set<FileSystemSyncAccessHandle>()\n\n  constructor(\n    dataDir: string,\n    {\n      initialPoolSize = 1000,\n      maintainedPoolSize = 100,\n      debug = false,\n    }: OpfsAhpOptions = {},\n  ) {\n    super(dataDir, { debug })\n    this.initialPoolSize = initialPoolSize\n    this.maintainedPoolSize = maintainedPoolSize\n  }\n\n  async init(pg: PGlite, opts: Partial<PostgresMod>) {\n    await this.#init()\n    return super.init(pg, opts)\n  }\n\n  async syncToFs(relaxedDurability = false) {\n    await this.maybeCheckpointState()\n    await this.maintainPool()\n    if (!relaxedDurability) {\n      this.flush()\n    }\n  }\n\n  async closeFs(): Promise<void> {\n    for (const sh of this.#sh.values()) {\n      sh.close()\n    }\n    this.#stateSH.flush()\n    this.#stateSH.close()\n    this.pg!.Module.FS.quit()\n  }\n\n  // =============================================================================\n  // [NMT CUSTOMIZATION] Emergency cleanup of all access handles\n  // =============================================================================\n  // RATIONALE: If PGlite crashes during initialization (e.g., _pgl_backend()\n  // throws \"RuntimeError: unreachable\"), closeFs() is never called and all\n  // OPFS-AHP sync access handles are leaked. This causes subsequent connection\n  // attempts to fail with \"NoModificationAllowedError: Access handle is already open\".\n  //\n  // This method differs from closeFs() in that it:\n  // 1. Catches and logs errors for each handle (doesn't throw on first error)\n  // 2. Clears internal maps to prevent reuse of stale handles\n  // 3. Does NOT call FS.quit() since the FS may be in an inconsistent state\n  //\n  // UPSTREAMABLE: This fixes a real bug where handles leak on crash.\n  //\n  // See: docs/debugging/pglite-opfs-root-cause-analysis.md\n  // =============================================================================\n  async emergencyCloseAllHandles(): Promise<void> {\n    console.info('[OpfsAhpFS] emergencyCloseAllHandles: starting emergency cleanup...')\n    let closedCount = 0\n    let errorCount = 0\n\n    // Close all sync access handles from the main pool\n    for (const [path, sh] of this.#sh.entries()) {\n      try {\n        sh.close()\n        closedCount++\n        console.debug(`[OpfsAhpFS] emergencyCloseAllHandles: closed handle for ${path}`)\n      } catch (e) {\n        console.warn(`[OpfsAhpFS] emergencyCloseAllHandles: error closing handle for ${path}:`, e)\n        errorCount++\n      }\n    }\n    this.#sh.clear()\n\n    // Clear file handles map (these don't need explicit closing, but clear for consistency)\n    this.#fh.clear()\n\n    // Clear open handle tracking\n    this.#openHandlePaths.clear()\n    this.#openHandleIds.clear()\n\n    // Close any unsynced handles\n    for (const sh of this.#unsyncedSH) {\n      try {\n        sh.close()\n        closedCount++\n      } catch (e) {\n        console.warn('[OpfsAhpFS] emergencyCloseAllHandles: error closing unsynced handle:', e)\n        errorCount++\n      }\n    }\n    this.#unsyncedSH.clear()\n\n    // Close state handle (critical for releasing the lock on state.txt)\n    if (this.#stateSH) {\n      try {\n        this.#stateSH.flush()\n        this.#stateSH.close()\n        console.debug('[OpfsAhpFS] emergencyCloseAllHandles: closed state handle')\n        closedCount++\n      } catch (e) {\n        console.warn('[OpfsAhpFS] emergencyCloseAllHandles: error closing state handle:', e)\n        errorCount++\n      }\n    }\n\n    console.info(\n      `[OpfsAhpFS] emergencyCloseAllHandles: complete (closed=${closedCount}, errors=${errorCount})`\n    )\n  }\n\n  async #init() {\n    // =============================================================================\n    // [NMT CUSTOMIZATION] Handle creation logging for debugging\n    // =============================================================================\n    // RATIONALE: When debugging Access Handle leaks or initialization failures,\n    // it's helpful to see exactly when handles are created. This logging helps\n    // trace the handle lifecycle and identify where leaks occur.\n    //\n    // UPSTREAMABLE: Pure diagnostics, no behavior change.\n    //\n    // See: docs/debugging/pglite-opfs-root-cause-analysis.md\n    // =============================================================================\n    console.info(`[OpfsAhpFS] #init: starting OPFS-AHP initialization for dataDir=${this.dataDir}`)\n\n    this.#opfsRootAh = await navigator.storage.getDirectory()\n    console.debug('[OpfsAhpFS] #init: got OPFS root directory handle')\n\n    this.#rootAh = await this.#resolveOpfsDirectory(this.dataDir!, {\n      create: true,\n    })\n    console.debug(`[OpfsAhpFS] #init: resolved root directory handle for ${this.dataDir}`)\n\n    this.#dataDirAh = await this.#resolveOpfsDirectory(DATA_DIR, {\n      from: this.#rootAh,\n      create: true,\n    })\n    console.debug(`[OpfsAhpFS] #init: resolved data directory handle for ${DATA_DIR}`)\n\n    this.#stateFH = await this.#rootAh.getFileHandle(STATE_FILE, {\n      create: true,\n    })\n    console.debug(`[OpfsAhpFS] #init: got file handle for ${STATE_FILE}`)\n\n    // This is a critical point - creating the sync access handle acquires an exclusive lock\n    console.info('[OpfsAhpFS] #init: creating state sync access handle (exclusive lock)...')\n    this.#stateSH = await (this.#stateFH as any).createSyncAccessHandle()\n    console.info('[OpfsAhpFS] #init: state sync access handle created successfully')\n\n    const stateAB = new ArrayBuffer(this.#stateSH.getSize())\n    this.#stateSH.read(stateAB, { at: 0 })\n    let state: State\n    const stateLines = new TextDecoder().decode(stateAB).split('\\n')\n    // Line 1 is a base state object.\n    // Lines 1+n are WAL entries.\n\n    let isNewState = false\n    try {\n      state = JSON.parse(stateLines[0])\n    } catch (e) {\n      state = {\n        root: {\n          type: 'directory',\n          lastModified: Date.now(),\n          mode: INITIAL_MODE.DIR,\n          children: {},\n        },\n        pool: [],\n      }\n      // write new state to file\n      this.#stateSH.truncate(0)\n      this.#stateSH.write(new TextEncoder().encode(JSON.stringify(state)), {\n        at: 0,\n      })\n      isNewState = true\n    }\n    this.state = state\n\n    // Apply WAL entries\n    const wal = stateLines\n      .slice(1)\n      .filter(Boolean)\n      .map((line) => JSON.parse(line))\n    for (const entry of wal) {\n      const methodName = `_${entry.opp}State`\n      if (typeof this[methodName as keyof this] === 'function') {\n        try {\n          const method = this[methodName as keyof this] as any\n          method.bind(this)(...entry.args)\n        } catch (e) {\n          console.warn('Error applying OPFS AHP WAL entry', entry, e)\n        }\n      }\n    }\n\n    // Open all file handles for dir tree\n    const walkPromises: Promise<void>[] = []\n    const walk = async (node: Node) => {\n      if (node.type === 'file') {\n        try {\n          const fh = await this.#dataDirAh.getFileHandle(node.backingFilename)\n          const sh: FileSystemSyncAccessHandle = await (\n            fh as any\n          ).createSyncAccessHandle()\n          this.#fh.set(node.backingFilename, fh)\n\n          this.#sh.set(node.backingFilename, sh)\n        } catch (e) {\n          console.error('Error opening file handle for node', node, e)\n        }\n      } else {\n        for (const child of Object.values(node.children)) {\n          walkPromises.push(walk(child))\n        }\n      }\n    }\n    await walk(this.state.root)\n\n    // Open all pool file handles\n    const poolPromises: Promise<void>[] = []\n    for (const filename of this.state.pool) {\n      poolPromises.push(\n        // eslint-disable-next-line no-async-promise-executor\n        new Promise<void>(async (resolve) => {\n          if (this.#fh.has(filename)) {\n            console.warn('File handle already exists for pool file', filename)\n          }\n          const fh = await this.#dataDirAh.getFileHandle(filename)\n          const sh: FileSystemSyncAccessHandle = await (\n            fh as any\n          ).createSyncAccessHandle()\n          this.#fh.set(filename, fh)\n          this.#sh.set(filename, sh)\n          resolve()\n        }),\n      )\n    }\n\n    await Promise.all([...walkPromises, ...poolPromises])\n\n    await this.maintainPool(\n      isNewState ? this.initialPoolSize : this.maintainedPoolSize,\n    )\n  }\n\n  async maintainPool(size?: number) {\n    size = size || this.maintainedPoolSize\n    const change = size - this.state.pool.length\n    const promises: Promise<void>[] = []\n    for (let i = 0; i < change; i++) {\n      promises.push(\n        // eslint-disable-next-line no-async-promise-executor\n        new Promise<void>(async (resolve) => {\n          ++this.poolCounter\n          const filename = `${(Date.now() - 1704063600).toString(16).padStart(8, '0')}-${this.poolCounter.toString(16).padStart(8, '0')}`\n          const fh = await this.#dataDirAh.getFileHandle(filename, {\n            create: true,\n          })\n          const sh: FileSystemSyncAccessHandle = await (\n            fh as any\n          ).createSyncAccessHandle()\n          this.#fh.set(filename, fh)\n          this.#sh.set(filename, sh)\n          this.#logWAL({\n            opp: 'createPoolFile',\n            args: [filename],\n          })\n          this.state.pool.push(filename)\n          resolve()\n        }),\n      )\n    }\n    for (let i = 0; i > change; i--) {\n      promises.push(\n        // eslint-disable-next-line no-async-promise-executor\n        new Promise<void>(async (resolve) => {\n          const filename = this.state.pool.pop()!\n          this.#logWAL({\n            opp: 'deletePoolFile',\n            args: [filename],\n          })\n          const fh = this.#fh.get(filename)!\n          const sh = this.#sh.get(filename)\n          sh?.close()\n          await this.#dataDirAh.removeEntry(fh.name)\n          this.#fh.delete(filename)\n          this.#sh.delete(filename)\n          resolve()\n        }),\n      )\n    }\n    await Promise.all(promises)\n  }\n\n  _createPoolFileState(filename: string) {\n    this.state.pool.push(filename)\n  }\n\n  _deletePoolFileState(filename: string) {\n    const index = this.state.pool.indexOf(filename)\n    if (index > -1) {\n      this.state.pool.splice(index, 1)\n    }\n  }\n\n  async maybeCheckpointState() {\n    if (Date.now() - this.lastCheckpoint > this.checkpointInterval) {\n      await this.checkpointState()\n    }\n  }\n\n  async checkpointState() {\n    const stateAB = new TextEncoder().encode(JSON.stringify(this.state))\n    this.#stateSH.truncate(0)\n    this.#stateSH.write(stateAB, { at: 0 })\n    this.#stateSH.flush()\n    this.lastCheckpoint = Date.now()\n  }\n\n  flush() {\n    for (const sh of this.#unsyncedSH) {\n      try {\n        sh.flush()\n      } catch (e) {\n        // The file may have been closed if it was deleted\n      }\n    }\n    this.#unsyncedSH.clear()\n  }\n\n  // Filesystem API:\n\n  chmod(path: string, mode: number): void {\n    this.#tryWithWAL({ opp: 'chmod', args: [path, mode] }, () => {\n      this._chmodState(path, mode)\n    })\n  }\n\n  _chmodState(path: string, mode: number): void {\n    const node = this.#resolvePath(path)\n    node.mode = mode\n  }\n\n  close(fd: number): void {\n    const path = this.#getPathFromFd(fd)\n    this.#openHandlePaths.delete(fd)\n    this.#openHandleIds.delete(path)\n  }\n\n  fstat(fd: number): FsStats {\n    const path = this.#getPathFromFd(fd)\n    return this.lstat(path)\n  }\n\n  lstat(path: string): FsStats {\n    const node = this.#resolvePath(path)\n    const size =\n      node.type === 'file' ? this.#sh.get(node.backingFilename)!.getSize() : 0\n    const blksize = 4096\n    return {\n      dev: 0,\n      ino: 0,\n      mode: node.mode,\n      nlink: 1,\n      uid: 0,\n      gid: 0,\n      rdev: 0,\n      size,\n      blksize,\n      blocks: Math.ceil(size / blksize),\n      atime: node.lastModified,\n      mtime: node.lastModified,\n      ctime: node.lastModified,\n    }\n  }\n\n  mkdir(path: string, options?: { recursive?: boolean; mode?: number }): void {\n    this.#tryWithWAL({ opp: 'mkdir', args: [path, options] }, () => {\n      this._mkdirState(path, options)\n    })\n  }\n\n  _mkdirState(\n    path: string,\n    options?: { recursive?: boolean; mode?: number },\n  ): void {\n    const parts = this.#pathParts(path)\n    const newDirName = parts.pop()!\n    const currentPath: string[] = []\n    let node = this.state.root\n    for (const part of parts) {\n      currentPath.push(path)\n      if (!Object.prototype.hasOwnProperty.call(node.children, part)) {\n        if (options?.recursive) {\n          this.mkdir(currentPath.join('/'))\n        } else {\n          throw new FsError('ENOENT', 'No such file or directory')\n        }\n      }\n      if (node.children[part].type !== 'directory') {\n        throw new FsError('ENOTDIR', 'Not a directory')\n      }\n      node = node.children[part] as DirectoryNode\n    }\n    if (Object.prototype.hasOwnProperty.call(node.children, newDirName)) {\n      throw new FsError('EEXIST', 'File exists')\n    }\n    const newDir: DirectoryNode = {\n      type: 'directory',\n      lastModified: Date.now(),\n      mode: options?.mode || INITIAL_MODE.DIR,\n      children: {},\n    }\n    node.children[newDirName] = newDir\n  }\n\n  open(path: string, _flags?: string, _mode?: number): number {\n    const node = this.#resolvePath(path)\n    if (node.type !== 'file') {\n      throw new FsError('EISDIR', 'Is a directory')\n    }\n    const handleId = this.#nextHandleId()\n    this.#openHandlePaths.set(handleId, path)\n    this.#openHandleIds.set(path, handleId)\n    return handleId\n  }\n\n  readdir(path: string): string[] {\n    const node = this.#resolvePath(path)\n    if (node.type !== 'directory') {\n      throw new FsError('ENOTDIR', 'Not a directory')\n    }\n    return Object.keys(node.children)\n  }\n\n  read(\n    fd: number,\n    buffer: Uint8Array, // Buffer to read into\n    offset: number, // Offset in buffer to start writing to\n    length: number, // Number of bytes to read\n    position: number, // Position in file to read from\n  ): number {\n    const path = this.#getPathFromFd(fd)\n    const node = this.#resolvePath(path)\n    if (node.type !== 'file') {\n      throw new FsError('EISDIR', 'Is a directory')\n    }\n    const sh = this.#sh.get(node.backingFilename)!\n    return sh.read(new Uint8Array(buffer.buffer as ArrayBuffer, offset, length), {\n      at: position,\n    })\n  }\n\n  rename(oldPath: string, newPath: string): void {\n    this.#tryWithWAL({ opp: 'rename', args: [oldPath, newPath] }, () => {\n      this._renameState(oldPath, newPath, true)\n    })\n  }\n\n  _renameState(oldPath: string, newPath: string, doFileOps = false): void {\n    const oldPathParts = this.#pathParts(oldPath)\n    const oldFilename = oldPathParts.pop()!\n    const oldParent = this.#resolvePath(oldPathParts.join('/')) as DirectoryNode\n    if (\n      !Object.prototype.hasOwnProperty.call(oldParent.children, oldFilename)\n    ) {\n      throw new FsError('ENOENT', 'No such file or directory')\n    }\n    const newPathParts = this.#pathParts(newPath)\n    const newFilename = newPathParts.pop()!\n    const newParent = this.#resolvePath(newPathParts.join('/')) as DirectoryNode\n    if (\n      doFileOps &&\n      Object.prototype.hasOwnProperty.call(newParent.children, newFilename)\n    ) {\n      // Overwrite, so return the underlying file to the pool\n      const node = newParent.children[newFilename]! as FileNode\n      const sh = this.#sh.get(node.backingFilename)!\n      sh.truncate(0)\n      this.state.pool.push(node.backingFilename)\n    }\n    newParent.children[newFilename] = oldParent.children[oldFilename]!\n    delete oldParent.children[oldFilename]\n  }\n\n  rmdir(path: string): void {\n    this.#tryWithWAL({ opp: 'rmdir', args: [path] }, () => {\n      this._rmdirState(path)\n    })\n  }\n\n  _rmdirState(path: string): void {\n    const pathParts = this.#pathParts(path)\n    const dirName = pathParts.pop()!\n    const parent = this.#resolvePath(pathParts.join('/')) as DirectoryNode\n    if (!Object.prototype.hasOwnProperty.call(parent.children, dirName)) {\n      throw new FsError('ENOENT', 'No such file or directory')\n    }\n    const node = parent.children[dirName]!\n    if (node.type !== 'directory') {\n      throw new FsError('ENOTDIR', 'Not a directory')\n    }\n    if (Object.keys(node.children).length > 0) {\n      throw new FsError('ENOTEMPTY', 'Directory not empty')\n    }\n    delete parent.children[dirName]\n  }\n\n  truncate(path: string, len = 0): void {\n    const node = this.#resolvePath(path)\n    if (node.type !== 'file') {\n      throw new FsError('EISDIR', 'Is a directory')\n    }\n    const sh = this.#sh.get(node.backingFilename)\n    if (!sh) {\n      throw new FsError('ENOENT', 'No such file or directory')\n    }\n    sh.truncate(len)\n    this.#unsyncedSH.add(sh)\n  }\n\n  unlink(path: string): void {\n    this.#tryWithWAL({ opp: 'unlink', args: [path] }, () => {\n      this._unlinkState(path, true)\n    })\n  }\n\n  _unlinkState(path: string, doFileOps = false): void {\n    const pathParts = this.#pathParts(path)\n    const filename = pathParts.pop()!\n    const dir = this.#resolvePath(pathParts.join('/')) as DirectoryNode\n    if (!Object.prototype.hasOwnProperty.call(dir.children, filename)) {\n      throw new FsError('ENOENT', 'No such file or directory')\n    }\n    const node = dir.children[filename]!\n    if (node.type !== 'file') {\n      throw new FsError('EISDIR', 'Is a directory')\n    }\n    delete dir.children[filename]\n    if (doFileOps) {\n      const sh = this.#sh.get(node.backingFilename)!\n      // We don't delete the file, it's truncated and returned to the pool\n      sh?.truncate(0)\n      this.#unsyncedSH.add(sh)\n      if (this.#openHandleIds.has(path)) {\n        this.#openHandlePaths.delete(this.#openHandleIds.get(path)!)\n        this.#openHandleIds.delete(path)\n      }\n    }\n    this.state.pool.push(node.backingFilename)\n  }\n\n  utimes(path: string, atime: number, mtime: number): void {\n    this.#tryWithWAL({ opp: 'utimes', args: [path, atime, mtime] }, () => {\n      this._utimesState(path, atime, mtime)\n    })\n  }\n\n  _utimesState(path: string, _atime: number, mtime: number): void {\n    const node = this.#resolvePath(path)\n    node.lastModified = mtime\n  }\n\n  writeFile(\n    path: string,\n    data: string | Uint8Array,\n    options?: { encoding?: string; mode?: number; flag?: string },\n  ): void {\n    const pathParts = this.#pathParts(path)\n    const filename = pathParts.pop()!\n    const parent = this.#resolvePath(pathParts.join('/')) as DirectoryNode\n\n    if (!Object.prototype.hasOwnProperty.call(parent.children, filename)) {\n      if (this.state.pool.length === 0) {\n        throw new Error('No more file handles available in the pool')\n      }\n      const node: Node = {\n        type: 'file',\n        lastModified: Date.now(),\n        mode: options?.mode || INITIAL_MODE.FILE,\n        backingFilename: this.state.pool.pop()!,\n      }\n      parent.children[filename] = node\n      this.#logWAL({\n        opp: 'createFileNode',\n        args: [path, node],\n      })\n    } else {\n      const node = parent.children[filename] as FileNode\n      node.lastModified = Date.now()\n      this.#logWAL({\n        opp: 'setLastModified',\n        args: [path, node.lastModified],\n      })\n    }\n    const node = parent.children[filename] as FileNode\n    const sh = this.#sh.get(node.backingFilename)!\n    // Files in pool are empty, only write if data is provided\n    if (data.length > 0) {\n      sh.write(\n        typeof data === 'string'\n          ? new TextEncoder().encode(data)\n          : new Uint8Array(data),\n        { at: 0 },\n      )\n      if (path.startsWith('/pg_wal')) {\n        this.#unsyncedSH.add(sh)\n      }\n    }\n  }\n\n  _createFileNodeState(path: string, node: FileNode): FileNode {\n    const pathParts = this.#pathParts(path)\n    const filename = pathParts.pop()!\n    const parent = this.#resolvePath(pathParts.join('/')) as DirectoryNode\n    parent.children[filename] = node\n    // remove backingFilename from pool\n    const index = this.state.pool.indexOf(node.backingFilename)\n    if (index > -1) {\n      this.state.pool.splice(index, 1)\n    }\n    return node\n  }\n\n  _setLastModifiedState(path: string, lastModified: number): void {\n    const node = this.#resolvePath(path)\n    node.lastModified = lastModified\n  }\n\n  write(\n    fd: number,\n    buffer: Uint8Array, // Buffer to read from\n    offset: number, // Offset in buffer to start reading from\n    length: number, // Number of bytes to write\n    position: number, // Position in file to write to\n  ): number {\n    const path = this.#getPathFromFd(fd)\n    const node = this.#resolvePath(path)\n    if (node.type !== 'file') {\n      throw new FsError('EISDIR', 'Is a directory')\n    }\n    const sh = this.#sh.get(node.backingFilename)\n    if (!sh) {\n      throw new FsError('EBADF', 'Bad file descriptor')\n    }\n    // Note: buffer is actually an ArrayBuffer passed from base.ts (buffer.buffer)\n    // This is intentional - base.ts extracts the underlying ArrayBuffer from Int8Array\n    // and we create a Uint8Array view into it here\n    const ret = sh.write(new Uint8Array(buffer as unknown as ArrayBuffer, offset, length), {\n      at: position,\n    })\n    if (path.startsWith('/pg_wal')) {\n      this.#unsyncedSH.add(sh)\n    }\n    return ret\n  }\n\n  // Internal methods:\n\n  #tryWithWAL(entry: WALEntry, fn: () => void) {\n    const offset = this.#logWAL(entry)\n    try {\n      fn()\n    } catch (e) {\n      // Rollback WAL entry\n      this.#stateSH.truncate(offset)\n      throw e\n    }\n  }\n\n  #logWAL(entry: WALEntry) {\n    const entryJSON = JSON.stringify(entry)\n    const stateAB = new TextEncoder().encode(`\\n${entryJSON}`)\n    const offset = this.#stateSH.getSize()\n    this.#stateSH.write(stateAB, { at: offset })\n    this.#unsyncedSH.add(this.#stateSH)\n    return offset\n  }\n\n  #pathParts(path: string): string[] {\n    return path.split('/').filter(Boolean)\n  }\n\n  #resolvePath(path: string, from?: DirectoryNode): Node {\n    const parts = this.#pathParts(path)\n    let node: Node = from || this.state.root\n    for (const part of parts) {\n      if (node.type !== 'directory') {\n        throw new FsError('ENOTDIR', 'Not a directory')\n      }\n      if (!Object.prototype.hasOwnProperty.call(node.children, part)) {\n        throw new FsError('ENOENT', 'No such file or directory')\n      }\n      node = node.children[part]!\n    }\n    return node\n  }\n\n  #getPathFromFd(fd: number): string {\n    const path = this.#openHandlePaths.get(fd)\n    if (!path) {\n      throw new FsError('EBADF', 'Bad file descriptor')\n    }\n    return path\n  }\n\n  #nextHandleId(): number {\n    const id = ++this.#handleIdCounter\n    while (this.#openHandlePaths.has(id)) {\n      this.#handleIdCounter++\n    }\n    return id\n  }\n\n  async #resolveOpfsDirectory(\n    path: string,\n    options?: {\n      from?: FileSystemDirectoryHandle\n      create?: boolean\n    },\n  ): Promise<FileSystemDirectoryHandle> {\n    const parts = this.#pathParts(path)\n    let ah = options?.from || this.#opfsRootAh\n    for (const part of parts) {\n      ah = await ah.getDirectoryHandle(part, { create: options?.create })\n    }\n    return ah\n  }\n}\n\nclass FsError extends Error {\n  code?: number\n  constructor(code: number | keyof typeof ERRNO_CODES | null, message: string) {\n    super(message)\n    if (typeof code === 'number') {\n      this.code = code\n    } else if (typeof code === 'string') {\n      this.code = ERRNO_CODES[code]\n    }\n  }\n}\n","import type { PostgresMod } from '../postgresMod.js'\nimport type { PGlite } from '../pglite.js'\nimport { dumpTar, type DumpTarCompressionOptions } from './tarUtils.js'\n\nexport const WASM_PREFIX = '/tmp/pglite'\nexport const PGDATA = WASM_PREFIX + '/' + 'base'\n\nexport type FsType = 'nodefs' | 'idbfs' | 'memoryfs' | 'opfs-ahp'\n\n/**\n * Filesystem interface.\n * All virtual filesystems that are compatible with PGlite must implement\n * this interface.\n */\nexport interface Filesystem {\n  /**\n   * Initiate the filesystem and return the options to pass to the emscripten module.\n   */\n  init(\n    pg: PGlite,\n    emscriptenOptions: Partial<PostgresMod>,\n  ): Promise<{ emscriptenOpts: Partial<PostgresMod> }>\n\n  /**\n   * Sync the filesystem to any underlying storage.\n   */\n  syncToFs(relaxedDurability?: boolean): Promise<void>\n\n  /**\n   * Sync the filesystem from any underlying storage.\n   */\n  initialSyncFs(): Promise<void>\n\n  /**\n   * Dump the PGDATA dir from the filesystem to a gzipped tarball.\n   */\n  dumpTar(\n    dbname: string,\n    compression?: DumpTarCompressionOptions,\n  ): Promise<File | Blob>\n\n  /**\n   * Close the filesystem.\n   */\n  closeFs(): Promise<void>\n}\n\n/**\n * Base class for all emscripten built-in filesystems.\n */\nexport class EmscriptenBuiltinFilesystem implements Filesystem {\n  protected dataDir?: string\n  protected pg?: PGlite\n\n  constructor(dataDir?: string) {\n    this.dataDir = dataDir\n  }\n\n  async init(pg: PGlite, emscriptenOptions: Partial<PostgresMod>) {\n    this.pg = pg\n    return { emscriptenOpts: emscriptenOptions }\n  }\n\n  async syncToFs(_relaxedDurability?: boolean) {}\n\n  async initialSyncFs() {}\n\n  async closeFs() {}\n\n  async dumpTar(dbname: string, compression?: DumpTarCompressionOptions) {\n    return dumpTar(this.pg!.Module.FS, PGDATA, dbname, compression)\n  }\n}\n\n/**\n * Abstract base class for all custom virtual filesystems.\n * Each custom filesystem needs to implement an interface similar to the NodeJS FS API.\n */\nexport abstract class BaseFilesystem implements Filesystem {\n  protected dataDir?: string\n  protected pg?: PGlite\n  readonly debug: boolean\n\n  constructor(dataDir?: string, { debug = false }: { debug?: boolean } = {}) {\n    this.dataDir = dataDir\n    this.debug = debug\n  }\n\n  async syncToFs(_relaxedDurability?: boolean) {}\n\n  async initialSyncFs() {}\n\n  async closeFs() {}\n\n  async dumpTar(dbname: string, compression?: DumpTarCompressionOptions) {\n    return dumpTar(this.pg!.Module.FS, PGDATA, dbname, compression)\n  }\n\n  async init(pg: PGlite, emscriptenOptions: Partial<PostgresMod>) {\n    this.pg = pg\n    const options: Partial<PostgresMod> = {\n      ...emscriptenOptions,\n      preRun: [\n        ...(emscriptenOptions.preRun || []),\n        (mod: PostgresMod) => {\n          const EMFS = createEmscriptenFS(mod, this)\n          mod.FS.mkdir(PGDATA)\n          mod.FS.mount(EMFS, {}, PGDATA)\n        },\n      ],\n    }\n    return { emscriptenOpts: options }\n  }\n\n  // Filesystem API\n\n  abstract chmod(path: string, mode: number): void\n  abstract close(fd: number): void\n  abstract fstat(fd: number): FsStats\n  abstract lstat(path: string): FsStats\n  abstract mkdir(\n    path: string,\n    options?: { recursive?: boolean; mode?: number },\n  ): void\n  abstract open(path: string, flags?: string, mode?: number): number\n  abstract readdir(path: string): string[]\n  abstract read(\n    fd: number,\n    buffer: Uint8Array, // Buffer to read into\n    offset: number, // Offset in buffer to start writing to\n    length: number, // Number of bytes to read\n    position: number, // Position in file to read from\n  ): number\n  abstract rename(oldPath: string, newPath: string): void\n  abstract rmdir(path: string): void\n  abstract truncate(\n    path: string,\n    len: number, // Length to truncate to - defaults to 0\n  ): void\n  abstract unlink(path: string): void\n  abstract utimes(path: string, atime: number, mtime: number): void\n  abstract writeFile(\n    path: string,\n    data: string | Uint8Array,\n    options?: { encoding?: string; mode?: number; flag?: string },\n  ): void\n  abstract write(\n    fd: number,\n    buffer: Uint8Array, // Buffer to read from\n    offset: number, // Offset in buffer to start reading from\n    length: number, // Number of bytes to write\n    position: number, // Position in file to write to\n  ): number\n}\n\nexport type FsStats = {\n  dev: number\n  ino: number\n  mode: number\n  nlink: number\n  uid: number\n  gid: number\n  rdev: number\n  size: number\n  blksize: number\n  blocks: number\n  atime: number\n  mtime: number\n  ctime: number\n}\n\ntype EmscriptenFileSystem = Emscripten.FileSystemType & {\n  createNode: (\n    parent: FSNode | null,\n    name: string,\n    mode: number,\n    dev?: any,\n  ) => FSNode\n  node_ops: FS.NodeOps\n  stream_ops: FS.StreamOps & {\n    dup: (stream: FSStream) => void\n    mmap: (\n      stream: FSStream,\n      length: number,\n      position: number,\n      prot: any,\n      flags: any,\n    ) => { ptr: number; allocated: boolean }\n    msync: (\n      stream: FSStream,\n      buffer: Uint8Array,\n      offset: number,\n      length: number,\n      mmapFlags: any,\n    ) => number\n  }\n} & { [key: string]: any }\n\ntype FSNode = FS.FSNode & {\n  node_ops: FS.NodeOps\n  stream_ops: FS.StreamOps\n}\n\ntype FSStream = FS.FSStream & {\n  node: FSNode\n  shared: {\n    refcount: number\n  }\n}\n\ntype FSMount = FS.Mount & {\n  opts: {\n    root: string\n  }\n}\n\ntype EmscriptenFS = PostgresMod['FS'] & {\n  createNode: (\n    parent: FSNode | null,\n    name: string,\n    mode: number,\n    dev?: any,\n  ) => FSNode\n}\n\nexport const ERRNO_CODES = {\n  EBADF: 8,\n  EBADFD: 127,\n  EEXIST: 20,\n  EINVAL: 28,\n  EISDIR: 31,\n  ENODEV: 43,\n  ENOENT: 44,\n  ENOTDIR: 54,\n  ENOTEMPTY: 55,\n} as const\n\n/**\n * Create an emscripten filesystem that uses the BaseFilesystem.\n * @param Module The emscripten module\n * @param baseFS The BaseFilesystem implementation\n * @returns The emscripten filesystem\n */\nconst createEmscriptenFS = (Module: PostgresMod, baseFS: BaseFilesystem) => {\n  const FS = Module.FS as EmscriptenFS\n  const log = baseFS.debug ? console.log : null\n  const EMFS = {\n    tryFSOperation<T>(f: () => T): T {\n      try {\n        return f()\n      } catch (e: any) {\n        if (!e.code) throw e\n        if (e.code === 'UNKNOWN') throw new FS.ErrnoError(ERRNO_CODES.EINVAL)\n        throw new FS.ErrnoError(e.code)\n      }\n    },\n    mount(_mount: FSMount): FSNode {\n      return EMFS.createNode(null, '/', 16384 | 511, 0)\n    },\n    syncfs(\n      _mount: FS.Mount,\n      _populate: any, // This has the wrong type in @types/emscripten\n      _done: (err?: number | null) => unknown,\n    ): void {\n      // noop\n    },\n    createNode(\n      parent: FSNode | null,\n      name: string,\n      mode: number,\n      _dev?: any,\n    ): FSNode {\n      if (!FS.isDir(mode) && !FS.isFile(mode)) {\n        throw new FS.ErrnoError(28)\n      }\n      const node = FS.createNode(parent, name, mode)\n      node.node_ops = EMFS.node_ops\n      node.stream_ops = EMFS.stream_ops\n      return node\n    },\n    getMode: function (path: string): number {\n      log?.('getMode', path)\n      return EMFS.tryFSOperation(() => {\n        const stats = baseFS.lstat(path)\n        return stats.mode\n      })\n    },\n    realPath: function (node: FSNode): string {\n      const parts: string[] = []\n      while (node.parent !== node) {\n        parts.push(node.name)\n        node = node.parent as FSNode\n      }\n      parts.push((node.mount as FSMount).opts.root)\n      parts.reverse()\n      return parts.join('/')\n    },\n    node_ops: {\n      getattr(node: FSNode): FS.Stats {\n        log?.('getattr', EMFS.realPath(node))\n        const path = EMFS.realPath(node)\n        return EMFS.tryFSOperation(() => {\n          const stats = baseFS.lstat(path)\n          return {\n            ...stats,\n            dev: 0,\n            ino: node.id,\n            nlink: 1,\n            rdev: node.rdev,\n            atime: new Date(stats.atime),\n            mtime: new Date(stats.mtime),\n            ctime: new Date(stats.ctime),\n          }\n        })\n      },\n      setattr(node: FSNode, attr: FS.Stats): void {\n        log?.('setattr', EMFS.realPath(node), attr)\n        const path = EMFS.realPath(node)\n        EMFS.tryFSOperation(() => {\n          if (attr.mode !== undefined) {\n            baseFS.chmod(path, attr.mode)\n          }\n          if (attr.size !== undefined) {\n            baseFS.truncate(path, attr.size)\n          }\n          if (attr.timestamp !== undefined) {\n            baseFS.utimes(path, attr.timestamp, attr.timestamp)\n          }\n          if (attr.size !== undefined) {\n            baseFS.truncate(path, attr.size)\n          }\n        })\n      },\n      lookup(parent: FSNode, name: string): FSNode {\n        log?.('lookup', EMFS.realPath(parent), name)\n        const path = [EMFS.realPath(parent), name].join('/')\n        const mode = EMFS.getMode(path)\n        return EMFS.createNode(parent, name, mode)\n      },\n      mknod(parent: FSNode, name: string, mode: number, dev: unknown): FSNode {\n        log?.('mknod', EMFS.realPath(parent), name, mode, dev)\n        const node = EMFS.createNode(parent, name, mode, dev)\n        // create the backing node for this in the fs root as well\n        const path = EMFS.realPath(node)\n        return EMFS.tryFSOperation(() => {\n          if (FS.isDir(node.mode)) {\n            baseFS.mkdir(path, { mode })\n          } else {\n            baseFS.writeFile(path, '', { mode })\n          }\n          return node\n        })\n      },\n      rename(oldNode: FSNode, newDir: FSNode, newName: string): void {\n        log?.('rename', EMFS.realPath(oldNode), EMFS.realPath(newDir), newName)\n        const oldPath = EMFS.realPath(oldNode)\n        const newPath = [EMFS.realPath(newDir), newName].join('/')\n        EMFS.tryFSOperation(() => {\n          baseFS.rename(oldPath, newPath)\n        })\n        oldNode.name = newName\n      },\n      unlink(parent: FSNode, name: string): void {\n        log?.('unlink', EMFS.realPath(parent), name)\n        const path = [EMFS.realPath(parent), name].join('/')\n        try {\n          baseFS.unlink(path)\n        } catch (e: any) {\n          // no-op\n        }\n      },\n      rmdir(parent: FSNode, name: string): void {\n        log?.('rmdir', EMFS.realPath(parent), name)\n        const path = [EMFS.realPath(parent), name].join('/')\n        return EMFS.tryFSOperation(() => {\n          baseFS.rmdir(path)\n        })\n      },\n      readdir(node: FSNode): string[] {\n        log?.('readdir', EMFS.realPath(node))\n        const path = EMFS.realPath(node)\n        return EMFS.tryFSOperation(() => {\n          return baseFS.readdir(path)\n        })\n      },\n      symlink(parent: FSNode, newName: string, oldPath: string): void {\n        log?.('symlink', EMFS.realPath(parent), newName, oldPath)\n        // This is not supported by EMFS\n        throw new FS.ErrnoError(63)\n      },\n      readlink(node: FSNode): string {\n        log?.('readlink', EMFS.realPath(node))\n        // This is not supported by EMFS\n        throw new FS.ErrnoError(63)\n      },\n    },\n    stream_ops: {\n      open(stream: FSStream): void {\n        log?.('open stream', EMFS.realPath(stream.node))\n        const path = EMFS.realPath(stream.node)\n        return EMFS.tryFSOperation(() => {\n          if (FS.isFile(stream.node.mode)) {\n            stream.shared.refcount = 1\n            stream.nfd = baseFS.open(path)\n          }\n        })\n      },\n      close(stream: FSStream): void {\n        log?.('close stream', EMFS.realPath(stream.node))\n        return EMFS.tryFSOperation(() => {\n          if (\n            FS.isFile(stream.node.mode) &&\n            stream.nfd &&\n            --stream.shared.refcount === 0\n          ) {\n            baseFS.close(stream.nfd)\n          }\n        })\n      },\n      dup(stream: FSStream) {\n        log?.('dup stream', EMFS.realPath(stream.node))\n        stream.shared.refcount++\n      },\n      read(\n        stream: FSStream, // Stream to read from\n        buffer: Uint8Array, // Buffer to read into - Wrong type in @types/emscripten\n        offset: number, // Offset in buffer to start writing to\n        length: number, // Number of bytes to read\n        position: number, // Position in file to read from\n      ): number {\n        log?.(\n          'read stream',\n          EMFS.realPath(stream.node),\n          offset,\n          length,\n          position,\n        )\n        if (length === 0) return 0\n        const ret = EMFS.tryFSOperation(() =>\n          baseFS.read(\n            stream.nfd!,\n            buffer as unknown as Uint8Array,\n            offset,\n            length,\n            position,\n          ),\n        )\n        return ret\n      },\n      write(\n        stream: FSStream, // Stream to write to\n        buffer: Uint8Array, // Buffer to read from - Wrong type in @types/emscripten\n        offset: number, // Offset in buffer to start writing from\n        length: number, // Number of bytes to write\n        position: number, // Position in file to write to\n      ): number {\n        log?.(\n          'write stream',\n          EMFS.realPath(stream.node),\n          offset,\n          length,\n          position,\n        )\n        return EMFS.tryFSOperation(() =>\n          baseFS.write(\n            stream.nfd!,\n            buffer.buffer as unknown as Uint8Array,\n            offset,\n            length,\n            position,\n          ),\n        )\n      },\n      llseek(stream: FSStream, offset: number, whence: number): number {\n        log?.('llseek stream', EMFS.realPath(stream.node), offset, whence)\n        let position = offset\n        if (whence === 1) {\n          position += stream.position\n        } else if (whence === 2) {\n          if (FS.isFile(stream.node.mode)) {\n            EMFS.tryFSOperation(() => {\n              const stat = baseFS.fstat(stream.nfd!)\n              position += stat.size\n            })\n          }\n        }\n        if (position < 0) {\n          throw new FS.ErrnoError(28)\n        }\n        return position\n      },\n      mmap(\n        stream: FSStream,\n        length: number,\n        position: number,\n        prot: any,\n        flags: any,\n      ) {\n        log?.(\n          'mmap stream',\n          EMFS.realPath(stream.node),\n          length,\n          position,\n          prot,\n          flags,\n        )\n        if (!FS.isFile(stream.node.mode)) {\n          throw new FS.ErrnoError(ERRNO_CODES.ENODEV)\n        }\n\n        const ptr = (Module as any).mmapAlloc(length) // TODO: Fix type and check this is exported\n\n        EMFS.stream_ops.read(\n          stream,\n          Module.HEAP8 as unknown as Uint8Array,\n          ptr,\n          length,\n          position,\n        )\n        return { ptr, allocated: true }\n      },\n      msync(\n        stream: FSStream,\n        buffer: Uint8Array,\n        offset: number,\n        length: number,\n        mmapFlags: any,\n      ) {\n        log?.(\n          'msync stream',\n          EMFS.realPath(stream.node),\n          offset,\n          length,\n          mmapFlags,\n        )\n        EMFS.stream_ops.write(stream, buffer, 0, length, offset)\n        return 0\n      },\n    },\n  } satisfies EmscriptenFileSystem\n  return EMFS\n}\n","import { tar, untar, type TarFile, REGTYPE, DIRTYPE } from 'tinytar'\nimport type { FS } from '../postgresMod.js'\n\nexport type DumpTarCompressionOptions = 'none' | 'gzip' | 'auto'\n\nexport async function dumpTar(\n  FS: FS,\n  pgDataDir: string,\n  dbname: string = 'pgdata',\n  compression: DumpTarCompressionOptions = 'auto',\n): Promise<File | Blob> {\n  const tarball = createTarball(FS, pgDataDir)\n  const [compressed, zipped] = await maybeZip(tarball, compression)\n  const filename = dbname + (zipped ? '.tar.gz' : '.tar')\n  const type = zipped ? 'application/x-gzip' : 'application/x-tar'\n  if (typeof File !== 'undefined') {\n    return new File([compressed as BlobPart], filename, {\n      type,\n    })\n  } else {\n    return new Blob([compressed as BlobPart], {\n      type,\n    })\n  }\n}\n\nconst compressedMimeTypes = [\n  'application/x-gtar',\n  'application/x-tar+gzip',\n  'application/x-gzip',\n  'application/gzip',\n]\n\nexport async function loadTar(\n  FS: FS,\n  file: File | Blob,\n  pgDataDir: string,\n): Promise<void> {\n  let tarball = new Uint8Array(await file.arrayBuffer())\n  const filename =\n    typeof File !== 'undefined' && file instanceof File ? file.name : undefined\n  const compressed =\n    compressedMimeTypes.includes(file.type) ||\n    filename?.endsWith('.tgz') ||\n    filename?.endsWith('.tar.gz')\n  if (compressed) {\n    tarball = await unzip(tarball) as Uint8Array<ArrayBuffer>\n  }\n\n  let files\n  try {\n    files = untar(tarball)\n  } catch (e) {\n    if (e instanceof Error && e.message.includes('File is corrupted')) {\n      // The file may be compressed, but had the wrong mime type, try unzipping it\n      tarball = await unzip(tarball) as Uint8Array<ArrayBuffer>\n      files = untar(tarball)\n    } else {\n      throw e\n    }\n  }\n\n  // [NMT CUSTOMIZATION] Track pg_control extraction for debugging\n  let pgControlExtracted = false\n  let pgControlDataSize = 0\n\n  for (const file of files) {\n    const filePath = pgDataDir + file.name\n\n    // Ensure the directory structure exists\n    const dirPath = filePath.split('/').slice(0, -1)\n    for (let i = 1; i <= dirPath.length; i++) {\n      const dir = dirPath.slice(0, i).join('/')\n      if (!FS.analyzePath(dir).exists) {\n        FS.mkdir(dir)\n      }\n    }\n\n    // Write the file or directory\n    if (file.type === REGTYPE) {\n      // [NMT CUSTOMIZATION] Log pg_control extraction details\n      if (file.name.endsWith('pg_control') || file.name.includes('/pg_control')) {\n        pgControlExtracted = true\n        pgControlDataSize = file.data?.length ?? 0\n        console.info(\n          `[loadTar] Extracting pg_control: name=\"${file.name}\", ` +\n          `tarball.size=${file.size ?? 'undefined'}, ` +\n          `data.length=${pgControlDataSize}, ` +\n          `data is Uint8Array=${file.data instanceof Uint8Array}`\n        )\n        if (pgControlDataSize > 0 && pgControlDataSize < 100) {\n          // Log first few bytes if file is suspiciously small\n          console.warn(`[loadTar] pg_control data is suspiciously small! First bytes:`,\n            Array.from(file.data.slice(0, Math.min(20, pgControlDataSize))).map(b => b.toString(16).padStart(2, '0')).join(' ')\n          )\n        } else if (pgControlDataSize === 0) {\n          console.error(`[loadTar] pg_control has ZERO data bytes! This will cause _pgl_backend to crash.`)\n        }\n      }\n\n      FS.writeFile(filePath, file.data)\n\n      // [NMT CUSTOMIZATION] Verify pg_control was written correctly\n      if (file.name.endsWith('pg_control') || file.name.includes('/pg_control')) {\n        try {\n          const stat = FS.stat(filePath)\n          console.info(`[loadTar] pg_control stat after write: size=${stat.size}, mode=${stat.mode}`)\n          if (stat.size === 0) {\n            console.error(`[loadTar] CRITICAL: pg_control has 0 bytes after FS.writeFile! Write failed silently.`)\n          } else if (stat.size !== file.data.length) {\n            console.warn(`[loadTar] pg_control size mismatch: expected ${file.data.length}, got ${stat.size}`)\n          }\n        } catch (e) {\n          console.error(`[loadTar] Failed to stat pg_control after write:`, e)\n        }\n      }\n\n      FS.utime(\n        filePath,\n        dateToUnixTimestamp(file.modifyTime),\n        dateToUnixTimestamp(file.modifyTime),\n      )\n    } else if (file.type === DIRTYPE) {\n      FS.mkdir(filePath)\n    }\n  }\n\n  // [NMT CUSTOMIZATION] Verify pg_control was extracted\n  if (!pgControlExtracted) {\n    console.error(`[loadTar] pg_control was NOT found in tarball! Files extracted: ${files.length}`)\n  } else {\n    console.info(`[loadTar] pg_control extraction complete: ${pgControlDataSize} bytes written`)\n  }\n\n  // =============================================================================\n  // [NMT CUSTOMIZATION] Post-load validation and pg_control state logging\n  // =============================================================================\n  // RATIONALE: When using loadDataDir with a prebuilt tarball, _pgl_backend()\n  // can crash with \"RuntimeError: unreachable\" if the datadir is invalid or\n  // has an unexpected pg_control state. By validating immediately after load\n  // and logging the pg_control state, we can:\n  // 1. Fail fast on corrupt/incomplete tarballs before initdb runs\n  // 2. Capture diagnostic info about the database state for debugging\n  //\n  // UPSTREAMABLE: This improves error messages and debugging for all users\n  // of loadDataDir, especially when using dumpDataDir-generated tarballs.\n  //\n  // See: docs/debugging/pglite-opfs-root-cause-analysis.md\n  // =============================================================================\n  const requiredPaths = [\n    'PG_VERSION',\n    'postgresql.conf',\n    'base',\n    'global',\n    'global/pg_control',\n  ]\n  const missingPaths: string[] = []\n\n  for (const reqPath of requiredPaths) {\n    const fullPath = pgDataDir + '/' + reqPath\n    if (!FS.analyzePath(fullPath).exists) {\n      missingPaths.push(reqPath)\n    }\n  }\n\n  if (missingPaths.length > 0) {\n    const errorMsg = `[loadTar] VALIDATION FAILED: Missing required paths: ${missingPaths.join(', ')}`\n    console.error(errorMsg)\n    throw new Error(`Invalid PGlite datadir: missing required paths: ${missingPaths.join(', ')}`)\n  }\n\n  // Log pg_control state for debugging\n  // pg_control structure (from PostgreSQL src/include/catalog/pg_control.h):\n  // Offset 0-7:   system_identifier (uint64)\n  // Offset 8-11:  pg_control_version (uint32)\n  // Offset 12-15: catalog_version_no (uint32)\n  // Offset 16-19: state (DBState enum = uint32)\n  //\n  // DBState values:\n  // 0 = DB_STARTUP, 1 = DB_SHUTDOWNED, 2 = DB_SHUTDOWNED_IN_RECOVERY,\n  // 3 = DB_SHUTDOWNING, 4 = DB_IN_CRASH_RECOVERY, 5 = DB_IN_ARCHIVE_RECOVERY,\n  // 6 = DB_IN_PRODUCTION\n  try {\n    const pgControlPath = pgDataDir + '/global/pg_control'\n    const pgControlData = FS.readFile(pgControlPath, { encoding: 'binary' })\n    const fileSize = pgControlData.length\n\n    // First check file size - pg_control should be 8192 bytes\n    if (fileSize === 0) {\n      console.error(`[loadTar] pg_control file is EMPTY (0 bytes)! This will cause _pgl_backend to crash.`)\n    } else if (fileSize < 20) {\n      console.error(`[loadTar] pg_control file is too small (${fileSize} bytes, need at least 20)! Corrupt tarball?`)\n    } else {\n      // pg_control state is at offset 16, stored as uint32 (4 bytes, little-endian)\n      const stateView = new DataView(new Uint8Array(pgControlData).buffer)\n      const state = stateView.getUint32(16, true) // little-endian, OFFSET 16\n      const stateNames: Record<number, string> = {\n        0: 'DB_STARTUP',\n        1: 'DB_SHUTDOWNED',\n        2: 'DB_SHUTDOWNED_IN_RECOVERY',\n        3: 'DB_SHUTDOWNING',\n        4: 'DB_IN_CRASH_RECOVERY',\n        5: 'DB_IN_ARCHIVE_RECOVERY',\n        6: 'DB_IN_PRODUCTION',\n      }\n      console.info(\n        `[loadTar] pg_control state = ${state} (${stateNames[state] || 'UNKNOWN'}), ` +\n        `size = ${fileSize} bytes`\n      )\n    }\n  } catch (e) {\n    console.warn(`[loadTar] Could not read pg_control state:`, e)\n  }\n\n  console.info(`[loadTar] Validation passed: all ${requiredPaths.length} required paths present`)\n}\n\nfunction readDirectory(FS: FS, path: string) {\n  const files: TarFile[] = []\n\n  const traverseDirectory = (currentPath: string) => {\n    const entries = FS.readdir(currentPath)\n    entries.forEach((entry) => {\n      if (entry === '.' || entry === '..') {\n        return\n      }\n      const fullPath = currentPath + '/' + entry\n      const stats = FS.stat(fullPath)\n      const data = FS.isFile(stats.mode)\n        ? FS.readFile(fullPath, { encoding: 'binary' })\n        : new Uint8Array(0)\n      files.push({\n        name: fullPath.substring(path.length), // remove the root path\n        mode: stats.mode,\n        size: stats.size,\n        type: FS.isFile(stats.mode) ? REGTYPE : DIRTYPE,\n        modifyTime: stats.mtime,\n        data,\n      })\n      if (FS.isDir(stats.mode)) {\n        traverseDirectory(fullPath)\n      }\n    })\n  }\n\n  traverseDirectory(path)\n  return files\n}\n\nexport function createTarball(FS: FS, directoryPath: string) {\n  const files = readDirectory(FS, directoryPath)\n  const tarball = tar(files)\n  return tarball\n}\n\nexport async function maybeZip(\n  file: Uint8Array,\n  compression: DumpTarCompressionOptions = 'auto',\n): Promise<[Uint8Array, boolean]> {\n  if (compression === 'none') {\n    return [file, false]\n  } else if (typeof CompressionStream !== 'undefined') {\n    return [await zipBrowser(file), true]\n  } else if (\n    typeof process !== 'undefined' &&\n    process.versions &&\n    process.versions.node\n  ) {\n    return [await zipNode(file), true]\n  } else if (compression === 'auto') {\n    return [file, false]\n  } else {\n    throw new Error('Compression not supported in this environment')\n  }\n}\n\nexport async function zipBrowser(file: Uint8Array): Promise<Uint8Array> {\n  const cs = new CompressionStream('gzip')\n  const writer = cs.writable.getWriter()\n  const reader = cs.readable.getReader()\n\n  writer.write(file as BufferSource)\n  writer.close()\n\n  const chunks: Uint8Array[] = []\n\n  while (true) {\n    const { value, done } = await reader.read()\n    if (done) break\n    if (value) chunks.push(value)\n  }\n\n  const compressed = new Uint8Array(\n    chunks.reduce((acc, chunk) => acc + chunk.length, 0),\n  )\n  let offset = 0\n  chunks.forEach((chunk) => {\n    compressed.set(chunk, offset)\n    offset += chunk.length\n  })\n\n  return compressed\n}\n\nexport async function zipNode(file: Uint8Array): Promise<Uint8Array> {\n  const { promisify } = await import('util')\n  const { gzip } = await import('zlib')\n  const gzipPromise = promisify(gzip)\n  return await gzipPromise(file)\n}\n\nexport async function unzip(file: Uint8Array): Promise<Uint8Array> {\n  if (typeof CompressionStream !== 'undefined') {\n    return await unzipBrowser(file)\n  } else if (\n    typeof process !== 'undefined' &&\n    process.versions &&\n    process.versions.node\n  ) {\n    return await unzipNode(file)\n  } else {\n    throw new Error('Unsupported environment for decompression')\n  }\n}\n\nexport async function unzipBrowser(file: Uint8Array): Promise<Uint8Array> {\n  const ds = new DecompressionStream('gzip')\n  const writer = ds.writable.getWriter()\n  const reader = ds.readable.getReader()\n\n  writer.write(file as BufferSource)\n  writer.close()\n\n  const chunks: Uint8Array[] = []\n\n  while (true) {\n    const { value, done } = await reader.read()\n    if (done) break\n    if (value) chunks.push(value)\n  }\n\n  const decompressed = new Uint8Array(\n    chunks.reduce((acc, chunk) => acc + chunk.length, 0),\n  )\n  let offset = 0\n  chunks.forEach((chunk) => {\n    decompressed.set(chunk, offset)\n    offset += chunk.length\n  })\n\n  return decompressed\n}\n\nexport async function unzipNode(file: Uint8Array): Promise<Uint8Array> {\n  const { promisify } = await import('util')\n  const { gunzip } = await import('zlib')\n  const gunzipPromise = promisify(gunzip)\n  return await gunzipPromise(file)\n}\n\nfunction dateToUnixTimestamp(date: Date | number | undefined): number {\n  if (!date) {\n    return Math.floor(Date.now() / 1000)\n  } else {\n    return typeof date === 'number' ? date : Math.floor(date.getTime() / 1000)\n  }\n}\n"],"mappings":"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","names":["init_cjs_shims","__esmMin","require_utils","__commonJSMin","exports","module","init_cjs_shims","MAX_SAFE_INTEGER","undefined","isUndefined","value","isString","isDateTime","isObject","isFunction","isLength","isArray","isArrayLike","isArrayBuffer","map","array","iteratee","find","result","item","index","found","extend","target","toUint8Array","i","length","require_constants","__commonJSMin","exports","module","init_cjs_shims","NULL_CHAR","require_types","__commonJSMin","exports","module","init_cjs_shims","utils","constants","recordSize","defaultFileMode","defaultUid","defaultGid","posixHeader","file","field","formatTarString","buffer","offset","parseTarString","mode","formatTarNumber","result","parseTarNumber","formatTarDateTime","parseTarDateTime","fixUstarMagic","effectiveHeaderSize","header","last","value","chars","length","defaultValue","bytes","returnUnprocessed","index","calculateChecksum","skipChecksum","from","to","skipFrom","skipTo","whitespace","i","byte","require_tar","__commonJSMin","exports","module","init_cjs_shims","constants","utils","types","headerSize","file","dataSize","allocateBuffer","files","totalSize","writeHeader","buffer","offset","currentOffset","field","value","length","i","checksum","writeData","tar","require_untar","__commonJSMin","exports","module","init_cjs_shims","constants","utils","types","defaultOptions","excludeFields","messages","headerSize","header","dataSize","size","isEndOfFile","buffer","offset","from","to","i","readHeader","options","result","currentOffset","field","error","checksum","readData","createFile","data","name","untar","require_tinytar","__commonJSMin","exports","module","init_cjs_shims","utils","constants","tar","untar","opfs_ahp_exports","__export","OpfsAhpFS","__toCommonJS","init_cjs_shims","init_cjs_shims","init_cjs_shims","import_tinytar","dumpTar","FS","pgDataDir","dbname","compression","tarball","createTarball","compressed","zipped","maybeZip","filename","type","readDirectory","FS","path","files","traverseDirectory","currentPath","entry","fullPath","stats","data","createTarball","directoryPath","maybeZip","file","compression","zipBrowser","zipNode","cs","writer","reader","chunks","value","done","compressed","acc","chunk","offset","promisify","gzip","WASM_PREFIX","PGDATA","BaseFilesystem","dataDir","debug","_relaxedDurability","dbname","compression","dumpTar","PGDATA","pg","emscriptenOptions","mod","EMFS","createEmscriptenFS","ERRNO_CODES","Module","baseFS","FS","log","f","e","_mount","_populate","_done","parent","name","mode","_dev","node","path","parts","stats","attr","dev","oldNode","newDir","newName","oldPath","newPath","stream","buffer","offset","length","position","whence","stat","prot","flags","ptr","mmapFlags","STATE_FILE","DATA_DIR","INITIAL_MODE","_opfsRootAh","_rootAh","_dataDirAh","_stateFH","_stateSH","_fh","_sh","_handleIdCounter","_openHandlePaths","_openHandleIds","_unsyncedSH","_OpfsAhpFS_instances","init_fn","tryWithWAL_fn","logWAL_fn","pathParts_fn","resolvePath_fn","getPathFromFd_fn","nextHandleId_fn","resolveOpfsDirectory_fn","OpfsAhpFS","BaseFilesystem","dataDir","initialPoolSize","maintainedPoolSize","debug","__privateAdd","pg","opts","__privateMethod","relaxedDurability","sh","__privateGet","closedCount","errorCount","path","e","size","change","promises","resolve","filename","fh","index","stateAB","mode","node","fd","blksize","options","parts","newDirName","currentPath","part","FsError","newDir","_flags","_mode","handleId","buffer","offset","length","position","oldPath","newPath","doFileOps","oldPathParts","oldFilename","oldParent","newPathParts","newFilename","newParent","pathParts","dirName","parent","len","dir","atime","mtime","_atime","data","lastModified","ret","__privateSet","state","stateLines","isNewState","wal","line","entry","methodName","walkPromises","walk","child","poolPromises","fn","entryJSON","from","id","__privateWrapper","ah","code","message","ERRNO_CODES"]}