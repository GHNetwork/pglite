import{f as B,g as R}from"../chunk-G6E4R66U.js";import{e as i,f as g,g as D,h as r,i as _,j}from"../chunk-LXLR7NCL.js";j();var z="state.txt",L="data",T={DIR:16384,FILE:32768},I,k,O,x,f,b,y,M,F,N,w,n,W,P,E,S,m,H,J,C,$=class extends B{constructor(e,{initialPoolSize:t=1e3,maintainedPoolSize:o=100,debug:s=!1}={}){super(e,{debug:s});g(this,n);g(this,I);g(this,k);g(this,O);g(this,x);g(this,f);g(this,b,new Map);g(this,y,new Map);g(this,M,0);g(this,F,new Map);g(this,N,new Map);this.lastCheckpoint=0;this.checkpointInterval=1e3*5;this.poolCounter=0;g(this,w,new Set);this.initialPoolSize=t,this.maintainedPoolSize=o}async init(e,t){return await r(this,n,W).call(this),super.init(e,t)}async syncToFs(e=!1){await this.maybeCheckpointState(),await this.maintainPool(),e||this.flush()}async closeFs(){for(let e of i(this,y).values())e.close();i(this,f).flush(),i(this,f).close(),this.pg.Module.FS.quit()}async emergencyCloseAllHandles(){console.info("[OpfsAhpFS] emergencyCloseAllHandles: starting emergency cleanup...");let e=0,t=0;for(let[o,s]of i(this,y).entries())try{s.close(),e++,console.debug(`[OpfsAhpFS] emergencyCloseAllHandles: closed handle for ${o}`)}catch(c){console.warn(`[OpfsAhpFS] emergencyCloseAllHandles: error closing handle for ${o}:`,c),t++}i(this,y).clear(),i(this,b).clear(),i(this,F).clear(),i(this,N).clear();for(let o of i(this,w))try{o.close(),e++}catch(s){console.warn("[OpfsAhpFS] emergencyCloseAllHandles: error closing unsynced handle:",s),t++}if(i(this,w).clear(),i(this,f))try{i(this,f).flush(),i(this,f).close(),console.debug("[OpfsAhpFS] emergencyCloseAllHandles: closed state handle"),e++}catch(o){console.warn("[OpfsAhpFS] emergencyCloseAllHandles: error closing state handle:",o),t++}console.info(`[OpfsAhpFS] emergencyCloseAllHandles: complete (closed=${e}, errors=${t})`)}async maintainPool(e){e=e||this.maintainedPoolSize;let t=e-this.state.pool.length,o=[];for(let s=0;s<t;s++)o.push(new Promise(async c=>{++this.poolCounter;let a=`${(Date.now()-1704063600).toString(16).padStart(8,"0")}-${this.poolCounter.toString(16).padStart(8,"0")}`,h=await i(this,O).getFileHandle(a,{create:!0}),d=await h.createSyncAccessHandle();i(this,b).set(a,h),i(this,y).set(a,d),r(this,n,E).call(this,{opp:"createPoolFile",args:[a]}),this.state.pool.push(a),c()}));for(let s=0;s>t;s--)o.push(new Promise(async c=>{let a=this.state.pool.pop();r(this,n,E).call(this,{opp:"deletePoolFile",args:[a]});let h=i(this,b).get(a);i(this,y).get(a)?.close(),await i(this,O).removeEntry(h.name),i(this,b).delete(a),i(this,y).delete(a),c()}));await Promise.all(o)}_createPoolFileState(e){this.state.pool.push(e)}_deletePoolFileState(e){let t=this.state.pool.indexOf(e);t>-1&&this.state.pool.splice(t,1)}async maybeCheckpointState(){Date.now()-this.lastCheckpoint>this.checkpointInterval&&await this.checkpointState()}async checkpointState(){let e=new TextEncoder().encode(JSON.stringify(this.state));i(this,f).truncate(0),i(this,f).write(e,{at:0}),i(this,f).flush(),this.lastCheckpoint=Date.now()}flush(){for(let e of i(this,w))try{e.flush()}catch{}i(this,w).clear()}chmod(e,t){r(this,n,P).call(this,{opp:"chmod",args:[e,t]},()=>{this._chmodState(e,t)})}_chmodState(e,t){let o=r(this,n,m).call(this,e);o.mode=t}close(e){let t=r(this,n,H).call(this,e);i(this,F).delete(e),i(this,N).delete(t)}fstat(e){let t=r(this,n,H).call(this,e);return this.lstat(t)}lstat(e){let t=r(this,n,m).call(this,e),o=t.type==="file"?i(this,y).get(t.backingFilename).getSize():0,s=4096;return{dev:0,ino:0,mode:t.mode,nlink:1,uid:0,gid:0,rdev:0,size:o,blksize:s,blocks:Math.ceil(o/s),atime:t.lastModified,mtime:t.lastModified,ctime:t.lastModified}}mkdir(e,t){r(this,n,P).call(this,{opp:"mkdir",args:[e,t]},()=>{this._mkdirState(e,t)})}_mkdirState(e,t){let o=r(this,n,S).call(this,e),s=o.pop(),c=[],a=this.state.root;for(let d of o){if(c.push(e),!Object.prototype.hasOwnProperty.call(a.children,d))if(t?.recursive)this.mkdir(c.join("/"));else throw new p("ENOENT","No such file or directory");if(a.children[d].type!=="directory")throw new p("ENOTDIR","Not a directory");a=a.children[d]}if(Object.prototype.hasOwnProperty.call(a.children,s))throw new p("EEXIST","File exists");let h={type:"directory",lastModified:Date.now(),mode:t?.mode||T.DIR,children:{}};a.children[s]=h}open(e,t,o){if(r(this,n,m).call(this,e).type!=="file")throw new p("EISDIR","Is a directory");let c=r(this,n,J).call(this);return i(this,F).set(c,e),i(this,N).set(e,c),c}readdir(e){let t=r(this,n,m).call(this,e);if(t.type!=="directory")throw new p("ENOTDIR","Not a directory");return Object.keys(t.children)}read(e,t,o,s,c){let a=r(this,n,H).call(this,e),h=r(this,n,m).call(this,a);if(h.type!=="file")throw new p("EISDIR","Is a directory");return i(this,y).get(h.backingFilename).read(new Uint8Array(t.buffer,o,s),{at:c})}rename(e,t){r(this,n,P).call(this,{opp:"rename",args:[e,t]},()=>{this._renameState(e,t,!0)})}_renameState(e,t,o=!1){let s=r(this,n,S).call(this,e),c=s.pop(),a=r(this,n,m).call(this,s.join("/"));if(!Object.prototype.hasOwnProperty.call(a.children,c))throw new p("ENOENT","No such file or directory");let h=r(this,n,S).call(this,t),d=h.pop(),l=r(this,n,m).call(this,h.join("/"));if(o&&Object.prototype.hasOwnProperty.call(l.children,d)){let u=l.children[d];i(this,y).get(u.backingFilename).truncate(0),this.state.pool.push(u.backingFilename)}l.children[d]=a.children[c],delete a.children[c]}rmdir(e){r(this,n,P).call(this,{opp:"rmdir",args:[e]},()=>{this._rmdirState(e)})}_rmdirState(e){let t=r(this,n,S).call(this,e),o=t.pop(),s=r(this,n,m).call(this,t.join("/"));if(!Object.prototype.hasOwnProperty.call(s.children,o))throw new p("ENOENT","No such file or directory");let c=s.children[o];if(c.type!=="directory")throw new p("ENOTDIR","Not a directory");if(Object.keys(c.children).length>0)throw new p("ENOTEMPTY","Directory not empty");delete s.children[o]}truncate(e,t=0){let o=r(this,n,m).call(this,e);if(o.type!=="file")throw new p("EISDIR","Is a directory");let s=i(this,y).get(o.backingFilename);if(!s)throw new p("ENOENT","No such file or directory");s.truncate(t),i(this,w).add(s)}unlink(e){r(this,n,P).call(this,{opp:"unlink",args:[e]},()=>{this._unlinkState(e,!0)})}_unlinkState(e,t=!1){let o=r(this,n,S).call(this,e),s=o.pop(),c=r(this,n,m).call(this,o.join("/"));if(!Object.prototype.hasOwnProperty.call(c.children,s))throw new p("ENOENT","No such file or directory");let a=c.children[s];if(a.type!=="file")throw new p("EISDIR","Is a directory");if(delete c.children[s],t){let h=i(this,y).get(a.backingFilename);h?.truncate(0),i(this,w).add(h),i(this,N).has(e)&&(i(this,F).delete(i(this,N).get(e)),i(this,N).delete(e))}this.state.pool.push(a.backingFilename)}utimes(e,t,o){r(this,n,P).call(this,{opp:"utimes",args:[e,t,o]},()=>{this._utimesState(e,t,o)})}_utimesState(e,t,o){let s=r(this,n,m).call(this,e);s.lastModified=o}writeFile(e,t,o){let s=r(this,n,S).call(this,e),c=s.pop(),a=r(this,n,m).call(this,s.join("/"));if(Object.prototype.hasOwnProperty.call(a.children,c)){let l=a.children[c];l.lastModified=Date.now(),r(this,n,E).call(this,{opp:"setLastModified",args:[e,l.lastModified]})}else{if(this.state.pool.length===0)throw new Error("No more file handles available in the pool");let l={type:"file",lastModified:Date.now(),mode:o?.mode||T.FILE,backingFilename:this.state.pool.pop()};a.children[c]=l,r(this,n,E).call(this,{opp:"createFileNode",args:[e,l]})}let h=a.children[c],d=i(this,y).get(h.backingFilename);t.length>0&&(d.write(typeof t=="string"?new TextEncoder().encode(t):new Uint8Array(t),{at:0}),e.startsWith("/pg_wal")&&i(this,w).add(d))}_createFileNodeState(e,t){let o=r(this,n,S).call(this,e),s=o.pop(),c=r(this,n,m).call(this,o.join("/"));c.children[s]=t;let a=this.state.pool.indexOf(t.backingFilename);return a>-1&&this.state.pool.splice(a,1),t}_setLastModifiedState(e,t){let o=r(this,n,m).call(this,e);o.lastModified=t}write(e,t,o,s,c){let a=r(this,n,H).call(this,e),h=r(this,n,m).call(this,a);if(h.type!=="file")throw new p("EISDIR","Is a directory");let d=i(this,y).get(h.backingFilename);if(!d)throw new p("EBADF","Bad file descriptor");let l=d.write(new Uint8Array(t,o,s),{at:c});return a.startsWith("/pg_wal")&&i(this,w).add(d),l}};I=new WeakMap,k=new WeakMap,O=new WeakMap,x=new WeakMap,f=new WeakMap,b=new WeakMap,y=new WeakMap,M=new WeakMap,F=new WeakMap,N=new WeakMap,w=new WeakMap,n=new WeakSet,W=async function(){console.info(`[OpfsAhpFS] #init: starting OPFS-AHP initialization for dataDir=${this.dataDir}`),D(this,I,await navigator.storage.getDirectory()),console.debug("[OpfsAhpFS] #init: got OPFS root directory handle"),D(this,k,await r(this,n,C).call(this,this.dataDir,{create:!0})),console.debug(`[OpfsAhpFS] #init: resolved root directory handle for ${this.dataDir}`),D(this,O,await r(this,n,C).call(this,L,{from:i(this,k),create:!0})),console.debug(`[OpfsAhpFS] #init: resolved data directory handle for ${L}`),D(this,x,await i(this,k).getFileHandle(z,{create:!0})),console.debug(`[OpfsAhpFS] #init: got file handle for ${z}`),console.info("[OpfsAhpFS] #init: creating state sync access handle (exclusive lock)..."),D(this,f,await i(this,x).createSyncAccessHandle()),console.info("[OpfsAhpFS] #init: state sync access handle created successfully");let e=new ArrayBuffer(i(this,f).getSize());i(this,f).read(e,{at:0});let t,o=new TextDecoder().decode(e).split(`
`),s=!1;try{t=JSON.parse(o[0])}catch{t={root:{type:"directory",lastModified:Date.now(),mode:T.DIR,children:{}},pool:[]},i(this,f).truncate(0),i(this,f).write(new TextEncoder().encode(JSON.stringify(t)),{at:0}),s=!0}this.state=t;let c=o.slice(1).filter(Boolean).map(l=>JSON.parse(l));for(let l of c){let u=`_${l.opp}State`;if(typeof this[u]=="function")try{this[u].bind(this)(...l.args)}catch(A){console.warn("Error applying OPFS AHP WAL entry",l,A)}}let a=[],h=async l=>{if(l.type==="file")try{let u=await i(this,O).getFileHandle(l.backingFilename),A=await u.createSyncAccessHandle();i(this,b).set(l.backingFilename,u),i(this,y).set(l.backingFilename,A)}catch(u){console.error("Error opening file handle for node",l,u)}else for(let u of Object.values(l.children))a.push(h(u))};await h(this.state.root);let d=[];for(let l of this.state.pool)d.push(new Promise(async u=>{i(this,b).has(l)&&console.warn("File handle already exists for pool file",l);let A=await i(this,O).getFileHandle(l),G=await A.createSyncAccessHandle();i(this,b).set(l,A),i(this,y).set(l,G),u()}));await Promise.all([...a,...d]),await this.maintainPool(s?this.initialPoolSize:this.maintainedPoolSize)},P=function(e,t){let o=r(this,n,E).call(this,e);try{t()}catch(s){throw i(this,f).truncate(o),s}},E=function(e){let t=JSON.stringify(e),o=new TextEncoder().encode(`
${t}`),s=i(this,f).getSize();return i(this,f).write(o,{at:s}),i(this,w).add(i(this,f)),s},S=function(e){return e.split("/").filter(Boolean)},m=function(e,t){let o=r(this,n,S).call(this,e),s=t||this.state.root;for(let c of o){if(s.type!=="directory")throw new p("ENOTDIR","Not a directory");if(!Object.prototype.hasOwnProperty.call(s.children,c))throw new p("ENOENT","No such file or directory");s=s.children[c]}return s},H=function(e){let t=i(this,F).get(e);if(!t)throw new p("EBADF","Bad file descriptor");return t},J=function(){let e=++_(this,M)._;for(;i(this,F).has(e);)_(this,M)._++;return e},C=async function(e,t){let o=r(this,n,S).call(this,e),s=t?.from||i(this,I);for(let c of o)s=await s.getDirectoryHandle(c,{create:t?.create});return s};var p=class extends Error{constructor(v,e){super(e),typeof v=="number"?this.code=v:typeof v=="string"&&(this.code=R[v])}};export{$ as OpfsAhpFS};
//# sourceMappingURL=opfs-ahp.js.map