{"version":3,"sources":["../../src/fs/opfs-ahp.ts"],"sourcesContent":["import { BaseFilesystem, ERRNO_CODES, type FsStats } from './base.js'\nimport type { PostgresMod } from '../postgresMod.js'\nimport { PGlite } from '../pglite.js'\n\nexport interface OpfsAhpOptions {\n  initialPoolSize?: number\n  maintainedPoolSize?: number\n  debug?: boolean\n}\n\n// TypeScript doesn't have a built-in type for FileSystemSyncAccessHandle\nexport interface FileSystemSyncAccessHandle {\n  close(): void\n  flush(): void\n  getSize(): number\n  read(buffer: BufferSource, options: { at: number }): number\n  truncate(newSize: number): void\n  write(buffer: BufferSource, options: { at: number }): number\n}\n\n// State\n\nconst STATE_FILE = 'state.txt'\nconst DATA_DIR = 'data'\nconst INITIAL_MODE = {\n  DIR: 16384,\n  FILE: 32768,\n}\n\nexport interface State {\n  root: DirectoryNode\n  pool: PoolFilenames\n}\n\nexport type PoolFilenames = Array<string>\n\n// WAL\n\nexport interface WALEntry {\n  opp: string\n  args: any[]\n}\n\n// Node tree\n\nexport type NodeType = 'file' | 'directory'\n\ninterface BaseNode {\n  type: NodeType\n  lastModified: number\n  mode: number\n}\n\nexport interface FileNode extends BaseNode {\n  type: 'file'\n  backingFilename: string\n}\n\nexport interface DirectoryNode extends BaseNode {\n  type: 'directory'\n  children: { [filename: string]: Node }\n}\n\nexport type Node = FileNode | DirectoryNode\n\n/**\n * PGlite OPFS access handle pool filesystem.\n * Opens a pool of sync access handles and then allocates them as needed.\n */\nexport class OpfsAhpFS extends BaseFilesystem {\n  declare readonly dataDir: string\n  readonly initialPoolSize: number\n  readonly maintainedPoolSize: number\n\n  #opfsRootAh!: FileSystemDirectoryHandle\n  #rootAh!: FileSystemDirectoryHandle\n  #dataDirAh!: FileSystemDirectoryHandle\n\n  #stateFH!: FileSystemFileHandle\n  #stateSH!: FileSystemSyncAccessHandle\n\n  #fh: Map<string, FileSystemFileHandle> = new Map()\n  #sh: Map<string, FileSystemSyncAccessHandle> = new Map()\n\n  #handleIdCounter = 0\n  #openHandlePaths: Map<number, string> = new Map()\n  #openHandleIds: Map<string, number> = new Map()\n\n  state!: State\n  lastCheckpoint = 0\n  // [NMT CUSTOMIZATION] Reduced from 60 seconds to 5 seconds to minimize data loss window\n  // RATIONALE: With the original 60-second interval, data changes could be lost if the user\n  // closed the tab, reloaded the page, or the browser crashed before the checkpoint.\n  // A 5-second interval provides much better durability while maintaining acceptable performance.\n  // Combined with relaxedDurability: false, this ensures near-immediate data persistence.\n  checkpointInterval = 1000 * 5 // 5 seconds (was 60 seconds)\n  poolCounter = 0\n\n  #unsyncedSH = new Set<FileSystemSyncAccessHandle>()\n\n  constructor(\n    dataDir: string,\n    {\n      initialPoolSize = 1000,\n      maintainedPoolSize = 100,\n      debug = false,\n    }: OpfsAhpOptions = {},\n  ) {\n    super(dataDir, { debug })\n    this.initialPoolSize = initialPoolSize\n    this.maintainedPoolSize = maintainedPoolSize\n  }\n\n  async init(pg: PGlite, opts: Partial<PostgresMod>) {\n    await this.#init()\n    return super.init(pg, opts)\n  }\n\n  async syncToFs(relaxedDurability = false) {\n    await this.maybeCheckpointState()\n    await this.maintainPool()\n    if (!relaxedDurability) {\n      this.flush()\n    }\n  }\n\n  async closeFs(): Promise<void> {\n    for (const sh of this.#sh.values()) {\n      sh.close()\n    }\n    this.#stateSH.flush()\n    this.#stateSH.close()\n    this.pg!.Module.FS.quit()\n  }\n\n  // =============================================================================\n  // [NMT CUSTOMIZATION] Emergency cleanup of all access handles\n  // =============================================================================\n  // RATIONALE: If PGlite crashes during initialization (e.g., _pgl_backend()\n  // throws \"RuntimeError: unreachable\"), closeFs() is never called and all\n  // OPFS-AHP sync access handles are leaked. This causes subsequent connection\n  // attempts to fail with \"NoModificationAllowedError: Access handle is already open\".\n  //\n  // This method differs from closeFs() in that it:\n  // 1. Catches and logs errors for each handle (doesn't throw on first error)\n  // 2. Clears internal maps to prevent reuse of stale handles\n  // 3. Does NOT call FS.quit() since the FS may be in an inconsistent state\n  //\n  // UPSTREAMABLE: This fixes a real bug where handles leak on crash.\n  //\n  // See: docs/debugging/pglite-opfs-root-cause-analysis.md\n  // =============================================================================\n  async emergencyCloseAllHandles(): Promise<void> {\n    console.info('[OpfsAhpFS] emergencyCloseAllHandles: starting emergency cleanup...')\n    let closedCount = 0\n    let errorCount = 0\n\n    // Close all sync access handles from the main pool\n    for (const [path, sh] of this.#sh.entries()) {\n      try {\n        sh.close()\n        closedCount++\n        console.debug(`[OpfsAhpFS] emergencyCloseAllHandles: closed handle for ${path}`)\n      } catch (e) {\n        console.warn(`[OpfsAhpFS] emergencyCloseAllHandles: error closing handle for ${path}:`, e)\n        errorCount++\n      }\n    }\n    this.#sh.clear()\n\n    // Clear file handles map (these don't need explicit closing, but clear for consistency)\n    this.#fh.clear()\n\n    // Clear open handle tracking\n    this.#openHandlePaths.clear()\n    this.#openHandleIds.clear()\n\n    // Close any unsynced handles\n    for (const sh of this.#unsyncedSH) {\n      try {\n        sh.close()\n        closedCount++\n      } catch (e) {\n        console.warn('[OpfsAhpFS] emergencyCloseAllHandles: error closing unsynced handle:', e)\n        errorCount++\n      }\n    }\n    this.#unsyncedSH.clear()\n\n    // Close state handle (critical for releasing the lock on state.txt)\n    if (this.#stateSH) {\n      try {\n        this.#stateSH.flush()\n        this.#stateSH.close()\n        console.debug('[OpfsAhpFS] emergencyCloseAllHandles: closed state handle')\n        closedCount++\n      } catch (e) {\n        console.warn('[OpfsAhpFS] emergencyCloseAllHandles: error closing state handle:', e)\n        errorCount++\n      }\n    }\n\n    console.info(\n      `[OpfsAhpFS] emergencyCloseAllHandles: complete (closed=${closedCount}, errors=${errorCount})`\n    )\n  }\n\n  async #init() {\n    // =============================================================================\n    // [NMT CUSTOMIZATION] Handle creation logging for debugging\n    // =============================================================================\n    // RATIONALE: When debugging Access Handle leaks or initialization failures,\n    // it's helpful to see exactly when handles are created. This logging helps\n    // trace the handle lifecycle and identify where leaks occur.\n    //\n    // UPSTREAMABLE: Pure diagnostics, no behavior change.\n    //\n    // See: docs/debugging/pglite-opfs-root-cause-analysis.md\n    // =============================================================================\n    console.info(`[OpfsAhpFS] #init: starting OPFS-AHP initialization for dataDir=${this.dataDir}`)\n\n    this.#opfsRootAh = await navigator.storage.getDirectory()\n    console.debug('[OpfsAhpFS] #init: got OPFS root directory handle')\n\n    this.#rootAh = await this.#resolveOpfsDirectory(this.dataDir!, {\n      create: true,\n    })\n    console.debug(`[OpfsAhpFS] #init: resolved root directory handle for ${this.dataDir}`)\n\n    this.#dataDirAh = await this.#resolveOpfsDirectory(DATA_DIR, {\n      from: this.#rootAh,\n      create: true,\n    })\n    console.debug(`[OpfsAhpFS] #init: resolved data directory handle for ${DATA_DIR}`)\n\n    this.#stateFH = await this.#rootAh.getFileHandle(STATE_FILE, {\n      create: true,\n    })\n    console.debug(`[OpfsAhpFS] #init: got file handle for ${STATE_FILE}`)\n\n    // This is a critical point - creating the sync access handle acquires an exclusive lock\n    console.info('[OpfsAhpFS] #init: creating state sync access handle (exclusive lock)...')\n    this.#stateSH = await (this.#stateFH as any).createSyncAccessHandle()\n    console.info('[OpfsAhpFS] #init: state sync access handle created successfully')\n\n    const stateAB = new ArrayBuffer(this.#stateSH.getSize())\n    this.#stateSH.read(stateAB, { at: 0 })\n    let state: State\n    const stateLines = new TextDecoder().decode(stateAB).split('\\n')\n    // Line 1 is a base state object.\n    // Lines 1+n are WAL entries.\n\n    let isNewState = false\n    try {\n      state = JSON.parse(stateLines[0])\n    } catch (e) {\n      state = {\n        root: {\n          type: 'directory',\n          lastModified: Date.now(),\n          mode: INITIAL_MODE.DIR,\n          children: {},\n        },\n        pool: [],\n      }\n      // write new state to file\n      this.#stateSH.truncate(0)\n      this.#stateSH.write(new TextEncoder().encode(JSON.stringify(state)), {\n        at: 0,\n      })\n      isNewState = true\n    }\n    this.state = state\n\n    // Apply WAL entries\n    const wal = stateLines\n      .slice(1)\n      .filter(Boolean)\n      .map((line) => JSON.parse(line))\n    for (const entry of wal) {\n      const methodName = `_${entry.opp}State`\n      if (typeof this[methodName as keyof this] === 'function') {\n        try {\n          const method = this[methodName as keyof this] as any\n          method.bind(this)(...entry.args)\n        } catch (e) {\n          console.warn('Error applying OPFS AHP WAL entry', entry, e)\n        }\n      }\n    }\n\n    // Open all file handles for dir tree\n    const walkPromises: Promise<void>[] = []\n    const walk = async (node: Node) => {\n      if (node.type === 'file') {\n        try {\n          const fh = await this.#dataDirAh.getFileHandle(node.backingFilename)\n          const sh: FileSystemSyncAccessHandle = await (\n            fh as any\n          ).createSyncAccessHandle()\n          this.#fh.set(node.backingFilename, fh)\n\n          this.#sh.set(node.backingFilename, sh)\n        } catch (e) {\n          console.error('Error opening file handle for node', node, e)\n        }\n      } else {\n        for (const child of Object.values(node.children)) {\n          walkPromises.push(walk(child))\n        }\n      }\n    }\n    await walk(this.state.root)\n\n    // Open all pool file handles\n    const poolPromises: Promise<void>[] = []\n    for (const filename of this.state.pool) {\n      poolPromises.push(\n        // eslint-disable-next-line no-async-promise-executor\n        new Promise<void>(async (resolve) => {\n          if (this.#fh.has(filename)) {\n            console.warn('File handle already exists for pool file', filename)\n          }\n          const fh = await this.#dataDirAh.getFileHandle(filename)\n          const sh: FileSystemSyncAccessHandle = await (\n            fh as any\n          ).createSyncAccessHandle()\n          this.#fh.set(filename, fh)\n          this.#sh.set(filename, sh)\n          resolve()\n        }),\n      )\n    }\n\n    await Promise.all([...walkPromises, ...poolPromises])\n\n    await this.maintainPool(\n      isNewState ? this.initialPoolSize : this.maintainedPoolSize,\n    )\n  }\n\n  async maintainPool(size?: number) {\n    size = size || this.maintainedPoolSize\n    const change = size - this.state.pool.length\n    const promises: Promise<void>[] = []\n    for (let i = 0; i < change; i++) {\n      promises.push(\n        // eslint-disable-next-line no-async-promise-executor\n        new Promise<void>(async (resolve) => {\n          ++this.poolCounter\n          const filename = `${(Date.now() - 1704063600).toString(16).padStart(8, '0')}-${this.poolCounter.toString(16).padStart(8, '0')}`\n          const fh = await this.#dataDirAh.getFileHandle(filename, {\n            create: true,\n          })\n          const sh: FileSystemSyncAccessHandle = await (\n            fh as any\n          ).createSyncAccessHandle()\n          this.#fh.set(filename, fh)\n          this.#sh.set(filename, sh)\n          this.#logWAL({\n            opp: 'createPoolFile',\n            args: [filename],\n          })\n          this.state.pool.push(filename)\n          resolve()\n        }),\n      )\n    }\n    for (let i = 0; i > change; i--) {\n      promises.push(\n        // eslint-disable-next-line no-async-promise-executor\n        new Promise<void>(async (resolve) => {\n          const filename = this.state.pool.pop()!\n          this.#logWAL({\n            opp: 'deletePoolFile',\n            args: [filename],\n          })\n          const fh = this.#fh.get(filename)!\n          const sh = this.#sh.get(filename)\n          sh?.close()\n          await this.#dataDirAh.removeEntry(fh.name)\n          this.#fh.delete(filename)\n          this.#sh.delete(filename)\n          resolve()\n        }),\n      )\n    }\n    await Promise.all(promises)\n  }\n\n  _createPoolFileState(filename: string) {\n    this.state.pool.push(filename)\n  }\n\n  _deletePoolFileState(filename: string) {\n    const index = this.state.pool.indexOf(filename)\n    if (index > -1) {\n      this.state.pool.splice(index, 1)\n    }\n  }\n\n  async maybeCheckpointState() {\n    if (Date.now() - this.lastCheckpoint > this.checkpointInterval) {\n      await this.checkpointState()\n    }\n  }\n\n  async checkpointState() {\n    const stateAB = new TextEncoder().encode(JSON.stringify(this.state))\n    this.#stateSH.truncate(0)\n    this.#stateSH.write(stateAB, { at: 0 })\n    this.#stateSH.flush()\n    this.lastCheckpoint = Date.now()\n  }\n\n  flush() {\n    for (const sh of this.#unsyncedSH) {\n      try {\n        sh.flush()\n      } catch (e) {\n        // The file may have been closed if it was deleted\n      }\n    }\n    this.#unsyncedSH.clear()\n  }\n\n  // Filesystem API:\n\n  chmod(path: string, mode: number): void {\n    this.#tryWithWAL({ opp: 'chmod', args: [path, mode] }, () => {\n      this._chmodState(path, mode)\n    })\n  }\n\n  _chmodState(path: string, mode: number): void {\n    const node = this.#resolvePath(path)\n    node.mode = mode\n  }\n\n  close(fd: number): void {\n    const path = this.#getPathFromFd(fd)\n    this.#openHandlePaths.delete(fd)\n    this.#openHandleIds.delete(path)\n  }\n\n  fstat(fd: number): FsStats {\n    const path = this.#getPathFromFd(fd)\n    return this.lstat(path)\n  }\n\n  lstat(path: string): FsStats {\n    const node = this.#resolvePath(path)\n    const size =\n      node.type === 'file' ? this.#sh.get(node.backingFilename)!.getSize() : 0\n    const blksize = 4096\n    return {\n      dev: 0,\n      ino: 0,\n      mode: node.mode,\n      nlink: 1,\n      uid: 0,\n      gid: 0,\n      rdev: 0,\n      size,\n      blksize,\n      blocks: Math.ceil(size / blksize),\n      atime: node.lastModified,\n      mtime: node.lastModified,\n      ctime: node.lastModified,\n    }\n  }\n\n  mkdir(path: string, options?: { recursive?: boolean; mode?: number }): void {\n    this.#tryWithWAL({ opp: 'mkdir', args: [path, options] }, () => {\n      this._mkdirState(path, options)\n    })\n  }\n\n  _mkdirState(\n    path: string,\n    options?: { recursive?: boolean; mode?: number },\n  ): void {\n    const parts = this.#pathParts(path)\n    const newDirName = parts.pop()!\n    const currentPath: string[] = []\n    let node = this.state.root\n    for (const part of parts) {\n      currentPath.push(path)\n      if (!Object.prototype.hasOwnProperty.call(node.children, part)) {\n        if (options?.recursive) {\n          this.mkdir(currentPath.join('/'))\n        } else {\n          throw new FsError('ENOENT', 'No such file or directory')\n        }\n      }\n      if (node.children[part].type !== 'directory') {\n        throw new FsError('ENOTDIR', 'Not a directory')\n      }\n      node = node.children[part] as DirectoryNode\n    }\n    if (Object.prototype.hasOwnProperty.call(node.children, newDirName)) {\n      throw new FsError('EEXIST', 'File exists')\n    }\n    const newDir: DirectoryNode = {\n      type: 'directory',\n      lastModified: Date.now(),\n      mode: options?.mode || INITIAL_MODE.DIR,\n      children: {},\n    }\n    node.children[newDirName] = newDir\n  }\n\n  open(path: string, _flags?: string, _mode?: number): number {\n    const node = this.#resolvePath(path)\n    if (node.type !== 'file') {\n      throw new FsError('EISDIR', 'Is a directory')\n    }\n    const handleId = this.#nextHandleId()\n    this.#openHandlePaths.set(handleId, path)\n    this.#openHandleIds.set(path, handleId)\n    return handleId\n  }\n\n  readdir(path: string): string[] {\n    const node = this.#resolvePath(path)\n    if (node.type !== 'directory') {\n      throw new FsError('ENOTDIR', 'Not a directory')\n    }\n    return Object.keys(node.children)\n  }\n\n  read(\n    fd: number,\n    buffer: Uint8Array, // Buffer to read into\n    offset: number, // Offset in buffer to start writing to\n    length: number, // Number of bytes to read\n    position: number, // Position in file to read from\n  ): number {\n    const path = this.#getPathFromFd(fd)\n    const node = this.#resolvePath(path)\n    if (node.type !== 'file') {\n      throw new FsError('EISDIR', 'Is a directory')\n    }\n    const sh = this.#sh.get(node.backingFilename)!\n    return sh.read(new Uint8Array(buffer.buffer as ArrayBuffer, offset, length), {\n      at: position,\n    })\n  }\n\n  rename(oldPath: string, newPath: string): void {\n    this.#tryWithWAL({ opp: 'rename', args: [oldPath, newPath] }, () => {\n      this._renameState(oldPath, newPath, true)\n    })\n  }\n\n  _renameState(oldPath: string, newPath: string, doFileOps = false): void {\n    const oldPathParts = this.#pathParts(oldPath)\n    const oldFilename = oldPathParts.pop()!\n    const oldParent = this.#resolvePath(oldPathParts.join('/')) as DirectoryNode\n    if (\n      !Object.prototype.hasOwnProperty.call(oldParent.children, oldFilename)\n    ) {\n      throw new FsError('ENOENT', 'No such file or directory')\n    }\n    const newPathParts = this.#pathParts(newPath)\n    const newFilename = newPathParts.pop()!\n    const newParent = this.#resolvePath(newPathParts.join('/')) as DirectoryNode\n    if (\n      doFileOps &&\n      Object.prototype.hasOwnProperty.call(newParent.children, newFilename)\n    ) {\n      // Overwrite, so return the underlying file to the pool\n      const node = newParent.children[newFilename]! as FileNode\n      const sh = this.#sh.get(node.backingFilename)!\n      sh.truncate(0)\n      this.state.pool.push(node.backingFilename)\n    }\n    newParent.children[newFilename] = oldParent.children[oldFilename]!\n    delete oldParent.children[oldFilename]\n  }\n\n  rmdir(path: string): void {\n    this.#tryWithWAL({ opp: 'rmdir', args: [path] }, () => {\n      this._rmdirState(path)\n    })\n  }\n\n  _rmdirState(path: string): void {\n    const pathParts = this.#pathParts(path)\n    const dirName = pathParts.pop()!\n    const parent = this.#resolvePath(pathParts.join('/')) as DirectoryNode\n    if (!Object.prototype.hasOwnProperty.call(parent.children, dirName)) {\n      throw new FsError('ENOENT', 'No such file or directory')\n    }\n    const node = parent.children[dirName]!\n    if (node.type !== 'directory') {\n      throw new FsError('ENOTDIR', 'Not a directory')\n    }\n    if (Object.keys(node.children).length > 0) {\n      throw new FsError('ENOTEMPTY', 'Directory not empty')\n    }\n    delete parent.children[dirName]\n  }\n\n  truncate(path: string, len = 0): void {\n    const node = this.#resolvePath(path)\n    if (node.type !== 'file') {\n      throw new FsError('EISDIR', 'Is a directory')\n    }\n    const sh = this.#sh.get(node.backingFilename)\n    if (!sh) {\n      throw new FsError('ENOENT', 'No such file or directory')\n    }\n    sh.truncate(len)\n    this.#unsyncedSH.add(sh)\n  }\n\n  unlink(path: string): void {\n    this.#tryWithWAL({ opp: 'unlink', args: [path] }, () => {\n      this._unlinkState(path, true)\n    })\n  }\n\n  _unlinkState(path: string, doFileOps = false): void {\n    const pathParts = this.#pathParts(path)\n    const filename = pathParts.pop()!\n    const dir = this.#resolvePath(pathParts.join('/')) as DirectoryNode\n    if (!Object.prototype.hasOwnProperty.call(dir.children, filename)) {\n      throw new FsError('ENOENT', 'No such file or directory')\n    }\n    const node = dir.children[filename]!\n    if (node.type !== 'file') {\n      throw new FsError('EISDIR', 'Is a directory')\n    }\n    delete dir.children[filename]\n    if (doFileOps) {\n      const sh = this.#sh.get(node.backingFilename)!\n      // We don't delete the file, it's truncated and returned to the pool\n      sh?.truncate(0)\n      this.#unsyncedSH.add(sh)\n      if (this.#openHandleIds.has(path)) {\n        this.#openHandlePaths.delete(this.#openHandleIds.get(path)!)\n        this.#openHandleIds.delete(path)\n      }\n    }\n    this.state.pool.push(node.backingFilename)\n  }\n\n  utimes(path: string, atime: number, mtime: number): void {\n    this.#tryWithWAL({ opp: 'utimes', args: [path, atime, mtime] }, () => {\n      this._utimesState(path, atime, mtime)\n    })\n  }\n\n  _utimesState(path: string, _atime: number, mtime: number): void {\n    const node = this.#resolvePath(path)\n    node.lastModified = mtime\n  }\n\n  writeFile(\n    path: string,\n    data: string | Uint8Array,\n    options?: { encoding?: string; mode?: number; flag?: string },\n  ): void {\n    const pathParts = this.#pathParts(path)\n    const filename = pathParts.pop()!\n    const parent = this.#resolvePath(pathParts.join('/')) as DirectoryNode\n\n    if (!Object.prototype.hasOwnProperty.call(parent.children, filename)) {\n      if (this.state.pool.length === 0) {\n        throw new Error('No more file handles available in the pool')\n      }\n      const node: Node = {\n        type: 'file',\n        lastModified: Date.now(),\n        mode: options?.mode || INITIAL_MODE.FILE,\n        backingFilename: this.state.pool.pop()!,\n      }\n      parent.children[filename] = node\n      this.#logWAL({\n        opp: 'createFileNode',\n        args: [path, node],\n      })\n    } else {\n      const node = parent.children[filename] as FileNode\n      node.lastModified = Date.now()\n      this.#logWAL({\n        opp: 'setLastModified',\n        args: [path, node.lastModified],\n      })\n    }\n    const node = parent.children[filename] as FileNode\n    const sh = this.#sh.get(node.backingFilename)!\n    // Files in pool are empty, only write if data is provided\n    if (data.length > 0) {\n      sh.write(\n        typeof data === 'string'\n          ? new TextEncoder().encode(data)\n          : new Uint8Array(data),\n        { at: 0 },\n      )\n      if (path.startsWith('/pg_wal')) {\n        this.#unsyncedSH.add(sh)\n      }\n    }\n  }\n\n  _createFileNodeState(path: string, node: FileNode): FileNode {\n    const pathParts = this.#pathParts(path)\n    const filename = pathParts.pop()!\n    const parent = this.#resolvePath(pathParts.join('/')) as DirectoryNode\n    parent.children[filename] = node\n    // remove backingFilename from pool\n    const index = this.state.pool.indexOf(node.backingFilename)\n    if (index > -1) {\n      this.state.pool.splice(index, 1)\n    }\n    return node\n  }\n\n  _setLastModifiedState(path: string, lastModified: number): void {\n    const node = this.#resolvePath(path)\n    node.lastModified = lastModified\n  }\n\n  write(\n    fd: number,\n    buffer: Uint8Array, // Buffer to read from\n    offset: number, // Offset in buffer to start reading from\n    length: number, // Number of bytes to write\n    position: number, // Position in file to write to\n  ): number {\n    const path = this.#getPathFromFd(fd)\n    const node = this.#resolvePath(path)\n    if (node.type !== 'file') {\n      throw new FsError('EISDIR', 'Is a directory')\n    }\n    const sh = this.#sh.get(node.backingFilename)\n    if (!sh) {\n      throw new FsError('EBADF', 'Bad file descriptor')\n    }\n    // Note: buffer is actually an ArrayBuffer passed from base.ts (buffer.buffer)\n    // This is intentional - base.ts extracts the underlying ArrayBuffer from Int8Array\n    // and we create a Uint8Array view into it here\n    const ret = sh.write(new Uint8Array(buffer as unknown as ArrayBuffer, offset, length), {\n      at: position,\n    })\n    if (path.startsWith('/pg_wal')) {\n      this.#unsyncedSH.add(sh)\n    }\n    return ret\n  }\n\n  // Internal methods:\n\n  #tryWithWAL(entry: WALEntry, fn: () => void) {\n    const offset = this.#logWAL(entry)\n    try {\n      fn()\n    } catch (e) {\n      // Rollback WAL entry\n      this.#stateSH.truncate(offset)\n      throw e\n    }\n  }\n\n  #logWAL(entry: WALEntry) {\n    const entryJSON = JSON.stringify(entry)\n    const stateAB = new TextEncoder().encode(`\\n${entryJSON}`)\n    const offset = this.#stateSH.getSize()\n    this.#stateSH.write(stateAB, { at: offset })\n    this.#unsyncedSH.add(this.#stateSH)\n    return offset\n  }\n\n  #pathParts(path: string): string[] {\n    return path.split('/').filter(Boolean)\n  }\n\n  #resolvePath(path: string, from?: DirectoryNode): Node {\n    const parts = this.#pathParts(path)\n    let node: Node = from || this.state.root\n    for (const part of parts) {\n      if (node.type !== 'directory') {\n        throw new FsError('ENOTDIR', 'Not a directory')\n      }\n      if (!Object.prototype.hasOwnProperty.call(node.children, part)) {\n        throw new FsError('ENOENT', 'No such file or directory')\n      }\n      node = node.children[part]!\n    }\n    return node\n  }\n\n  #getPathFromFd(fd: number): string {\n    const path = this.#openHandlePaths.get(fd)\n    if (!path) {\n      throw new FsError('EBADF', 'Bad file descriptor')\n    }\n    return path\n  }\n\n  #nextHandleId(): number {\n    const id = ++this.#handleIdCounter\n    while (this.#openHandlePaths.has(id)) {\n      this.#handleIdCounter++\n    }\n    return id\n  }\n\n  async #resolveOpfsDirectory(\n    path: string,\n    options?: {\n      from?: FileSystemDirectoryHandle\n      create?: boolean\n    },\n  ): Promise<FileSystemDirectoryHandle> {\n    const parts = this.#pathParts(path)\n    let ah = options?.from || this.#opfsRootAh\n    for (const part of parts) {\n      ah = await ah.getDirectoryHandle(part, { create: options?.create })\n    }\n    return ah\n  }\n}\n\nclass FsError extends Error {\n  code?: number\n  constructor(code: number | keyof typeof ERRNO_CODES | null, message: string) {\n    super(message)\n    if (typeof code === 'number') {\n      this.code = code\n    } else if (typeof code === 'string') {\n      this.code = ERRNO_CODES[code]\n    }\n  }\n}\n"],"mappings":"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","names":["init_esm_shims","STATE_FILE","DATA_DIR","INITIAL_MODE","_opfsRootAh","_rootAh","_dataDirAh","_stateFH","_stateSH","_fh","_sh","_handleIdCounter","_openHandlePaths","_openHandleIds","_unsyncedSH","_OpfsAhpFS_instances","init_fn","tryWithWAL_fn","logWAL_fn","pathParts_fn","resolvePath_fn","getPathFromFd_fn","nextHandleId_fn","resolveOpfsDirectory_fn","OpfsAhpFS","BaseFilesystem","dataDir","initialPoolSize","maintainedPoolSize","debug","__privateAdd","pg","opts","__privateMethod","relaxedDurability","sh","__privateGet","closedCount","errorCount","path","e","size","change","promises","i","resolve","filename","fh","index","stateAB","mode","node","fd","blksize","options","parts","newDirName","currentPath","part","FsError","newDir","_flags","_mode","handleId","buffer","offset","length","position","oldPath","newPath","doFileOps","oldPathParts","oldFilename","oldParent","newPathParts","newFilename","newParent","pathParts","dirName","parent","len","dir","atime","mtime","_atime","data","lastModified","ret","__privateSet","state","stateLines","isNewState","wal","line","entry","methodName","walkPromises","walk","child","poolPromises","fn","entryJSON","from","id","__privateWrapper","ah","code","message","ERRNO_CODES"]}